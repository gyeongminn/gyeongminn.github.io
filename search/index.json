[{"content":"피터 린치의 이기는 투자 책을 고른 이유 요즘 미국 주식과 재테크에 관심이 많다. 매일 출근 길마다 미국 주식 방송을 보다 보니, 자연스럽게 주식이 오르내리는 이유에 대해 관심을 갖게 되었다.\n나는 미국 주식은 결국 우상향한다는 믿음이 있다. 주로 시장 지수를 추종하는 ETF 상품들을 포트폴리오에 담는다. \u0026ldquo;투자할 줄 모르면 그냥 S\u0026amp;P 500을 적립식으로 투자하라\u0026rdquo; 라는 말이 정말 좋은 조언이라고 생각한다.\n단순히 지수를 적립식으로 투자하는 것은 너무 지루하기에, 시장 상황을 보며 적절히 여러 종목들을 고르며 포트폴리오를 짜고 리밸런싱하고 있다. 아직까진 수익률도 나쁘지 않고 재미있다. 나는 내가 고심히 선정한 포트폴리오가 S\u0026amp;P 500은 이길 것이라고 막연히 생각해 왔지만, 계좌에서 항상 효자 노릇 하는 것은 S\u0026amp;P 500이었다.\n최적의 투자시점을 고민하기 보다 매달 정기적으로 투자를 하는 것이 개인 투자자들에게는 더 높은 승률을 가져다 줄 것이라고 피터 린치는 말한다. 우연히 읽은 서평에서 이 문구를 보고, 나는 이 책을 읽어보기로 결심했다.\n투자 조언 책에는 피터 린치의 원칙들과 투자 조언이 끊임없이 나온다. 아래는 중요한 투자 조언들을 간단하게 정리한 내용이다.\n비관론은 무시하라 피터 린치는 책에서 내내 시장을 믿고 걱정하지 말라고 한다. 비관론자보다 낙관론자가 수익률이 좋다. 경기 침체가 올 것이라는 뉴스에 휘둘리지 말라. 투자의 운명을 결정하는 것은 머리가 아니라 배짱이다. 대신 주식이 하락하는 것은 일상이니 대비만 잘 하면 된다.\n미래를 예측하려 하지 마라 최적의 투자 시점을 연구하는 것보다 정기적(적립식)으로 투자하는 것이 훨씬 승률이 좋다. 미래는 예측할 백미러로는 앞을 볼 수 없듯, 과거의 사건으로 미래를 예단하지 마라. 아무도 경제상황과 주식시장의 방향은 예측할 수 없다.\n잘 아는 주식에 투자하라 기업에 대해 자세히 설명할 수 있고, 왜 이 주식을 사야하는지 설명할 수 있는 기업에 투자하라. 이 기업이 왜 평소 자신이 잘 알고 있던 종목이라면 더 좋다.\n수익 구조가 간단한 기업에 투자하라 수익 구조를 쉽게 알 수 있는 기업에 투자하라. 그림으로 표현할 수 없는 아이디어에는 투자하지 마라. 재정이 복잡한 기업은 투자하지 마라. 참고로, 장기적으로 기업의 실적과 주가는 100% 같이 간다.\n후기 성장주 투자의 대가, 피터 린치의 투자 철학을 아주 쉽게 풀어 쓴 좋은 책이었다. 투자 관련 서적이라면 읽기 어려울 법도 한데, 스토리와 함께 쉬운 말로 풀어서 설명해 술술 읽혔다. 미국 주식에 입문하는 지인이 있다면 꼭 추천하고 싶은 책이다.\n피터 린치는 수없이이 시장에 대한 낙관론을 강조한다. \u0026ldquo;주말에 너무 깊이 생각하지 말고 뉴스의 부정적인 전망은 무시하라.\u0026rdquo; 라고 말할 정도이다. 나 역시 각종 뉴스에 따라 부화뇌동하지 말라는 피터 린치의 의견에 공감한다.\n위 서술한 내용 이외에도 배울 점이 많은 책이니, 주식 투자를 입문하는 사람들에겐 꼭 한번 읽어 보길 권하고 싶다.\n","date":"2025-10-12T00:00:00Z","image":"https://gyeongmin.kr/p/beating-the-street/image_hu5abfc073d05f6bd1948b16978b169afe_400095_120x120_fill_box_smart1_3.png","permalink":"https://gyeongmin.kr/p/beating-the-street/","title":"\u003c피터 린치의 이기는 투자\u003e를 읽고"},{"content":"\u003c!DOCTYPE html\u003e Bug Report Table Bug Report Example Preview Reset Fill Current Date/Time Copy Table to Clipboard Bug ID Overview Bug Name (Title) Bug Reporter Date/Time Submitted Prioritization Bug Severity Blocker Critical Major Normal Minor Trivial Bug Priority Top High Medium Low None Assigned to Details Steps to reproduce Expected Result Observed Result What actions is this bug blocking? Environment Platform OS Branch Commit # Note ","date":"2024-07-01T00:00:00Z","permalink":"https://gyeongmin.kr/p/bug-report/","title":"[Util] Bug Report Generator"},{"content":"ordered_set이란? g++에서 추가된 자료구조로, std::set과 유사하지만, 아래 두 연산을 $\\mathcal{O}(\\log N)$만에 수행할 수 있다.\norder_of_key(k) : k보다 작은 원소의 개수\nfind_by_order(k) : 오름차순으로 정렬했을 때 k번째 원소 (zero-based)\n집합 내부에서 원소의 추가/삭제가 빈번하게 이루어지며, 수시로 k번째 수를 찾아야하는 경우에 유용한 자료구조이다.\n1 2 3 4 5 6 7 #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt; #include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt; using namespace std; using namespace __gnu_pbds; typedef tree\u0026lt;int, null_type, less\u0026lt;\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; ordered_set; ordered_set os; 다만, 삭제하는 연산은 아래와 같이 따로 구현해주어야 한다.\n1 2 3 4 5 void erase(ordered_set \u0026amp;os, int value) { size_t index = os.order_of_key(value); auto iter = os.find_by_order(index); os.erase(iter); } ordered_set 사용 예제 order_of_key의 경우 value를 리턴하고, find_by_order의 경우 iterator를 리턴한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt; #include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt; using namespace std; using namespace __gnu_pbds; typedef tree\u0026lt;int, null_type, less\u0026lt;\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; ordered_set; void erase(ordered_set \u0026amp;os, int value) { size_t index = os.order_of_key(value); auto iter = os.find_by_order(index); os.erase(iter); } int main() { ordered_set os; os.insert(5); os.insert(4); os.insert(3); os.insert(3); os.insert(2); os.insert(1); for (int i : os) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; // 1 2 3 4 5 cout \u0026lt;\u0026lt; os.order_of_key(2) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; *os.find_by_order(2) \u0026lt;\u0026lt; endl; // 3 cout \u0026lt;\u0026lt; os.size() \u0026lt;\u0026lt; endl; // 5 erase(os, 2); cout \u0026lt;\u0026lt; os.size() \u0026lt;\u0026lt; endl; // 4 for (int i : os) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; // 1 3 4 5 cout \u0026lt;\u0026lt; os.order_of_key(2) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; *os.find_by_order(2) \u0026lt;\u0026lt; endl; // 4 } ordered_multi_set 사용 예제 중복 값을 허용한다.\nless\u0026lt;\u0026gt; 대신 less_equal\u0026lt;\u0026gt;를 넣어주면 된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt; #include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt; using namespace std; using namespace __gnu_pbds; typedef tree\u0026lt;int, null_type, less_equal\u0026lt;\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; ordered_multi_set; void erase(ordered_multi_set \u0026amp;oms, int value) { size_t index = oms.order_of_key(value); auto iter = oms.find_by_order(index); oms.erase(iter); } int main() { ordered_multi_set oms; oms.insert(5); oms.insert(4); oms.insert(3); oms.insert(3); oms.insert(2); oms.insert(1); for (int i : oms) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; // 1 2 3 3 4 5 cout \u0026lt;\u0026lt; oms.order_of_key(2) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; *oms.find_by_order(2) \u0026lt;\u0026lt; endl; // 3 cout \u0026lt;\u0026lt; oms.size() \u0026lt;\u0026lt; endl; // 6 erase(oms, 2); cout \u0026lt;\u0026lt; oms.size() \u0026lt;\u0026lt; endl; // 5 for (int i : oms) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; // 1 3 3 4 5 cout \u0026lt;\u0026lt; oms.order_of_key(2) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; *oms.find_by_order(2) \u0026lt;\u0026lt; endl; // 3 } BOJ 1572 중앙값 https://www.acmicpc.net/problem/1572\n세그트리/이분탐색 문제이지만, PBDS를 사용하면 쉽게 풀 수 있다.\n문제 풀이 온도 값이 1초마다 추가되며, 최근 K초 까지 온도의 중앙값을 다 더한 값을 구하는 문제이다.\n매 초마다 ordered_multi_set에 값을 추가해 준다.\nk초 이전에는 값 입력만 받고, k초부터는 중앙값을 구해준다. find_by_order()는 zero-based임에 유의하자.\n우리는 최근 k초까지의 값에만 관심 있기 때문에, k초 이후에는 k초 이전의 값은 삭제해 준다.\n중복값이 발생하므로 less_equal\u0026lt;\u0026gt;를 사용해 주자. 정답은 $2^{63}-1$ 이하이므로, int범위를 초과한다.\n","date":"2024-04-10T00:00:00Z","image":"https://gyeongmin.kr/images/algorithm.png","permalink":"https://gyeongmin.kr/p/pbds/","title":"C++ STL PBDS (Policy based data structures)"},{"content":"PANDA: Adapting Pretrained Features for Anomaly Detection and Segmentation 논문 PDF\nIntroduction Anomaly Detection Anomaly는 정상의 범주에서 벗어나 있는 모든 것들을 의미한다.\n주어진 데이터셋에서 Anomaly들을 탐지하는 것을 Anomaly Detection (이상치 탐지)라 한다. 주로 정상 데이터셋만으로 학습을 진행하며, 주어진 이미지를 Normal / Anomaly로 구분해야 하기에 One-Class Classification (OCC) 라고도 부른다.\n본 논문에서는 Anomaly를 검출하는 세 분야를 다음과 같이 정의한다.\nAnomaly Detection: 훈련 과정에서 오직 정상 이미지만 사용하는 경우\nAnomaly Segmentation: 정상 이미지가 주어진 상태에서 Anomaly가 포함된 모든 픽셀을 탐지하는 경우\nOutlier Exposure: 이상 현상을 시뮬레이션하는 데에 외부 데이터셋 사용이 가능한 경우\n최근 대부분의 이상 탐지 방법들은 제한된 정상 훈련 데이터셋을 사용하여 데이터의 feature를 학습하며, 이것에 의존하고 있다.\nCatastrophic Collapse 특히 Multi-Class Calssifiaction보다 One-Class Classification 분야에서 전이 학습에 대한 연구가 부족한 상황이다. 이미지 전이 학습 분야에서는 Catastrophic Collapse가 잘 발생하기 때문이다. Catastrophic Collapse는 Normal과 Anomaly 데이터가 잘 구분되지 않고, feature 공간에서 동일한 지점에 매핑되는 현상을 말한다. 이 현상은 데이터의 패턴을 학습하지 못하거나 학습 과정에서 Overfitting에 빠지는 것에 기인하기 때문에, Early Stopping을 위해 Epoch를 잘 조절한다면 이를 방지할 수 있다.\n본 논문에서는 Catastrophic Collapse를 방지하기 위해 Epoch 수에 의존적이지 않은 early stopping variant 방법과 continual learning에서 영감을 받은 Elastic Regularization 기법을 제안하는데, 이는 뒤에서 자세히 설명하겠다.\nBackground 3-Stage Framework 일반적인 프레임워크는 세 단계로 구성된다. 정상 훈련 데이터셋 $D_{train} = \\{ x_1, x_2, \\dots, x_N \\} $이 주어졌다고 가정하자.\nInitial feature extractor\nInitial feature extractor인 $\\psi_0$는 pre-train을 통해 얻을 수 있으며, 손실 함수는 $L_{pretrain}$이다. auxiliary task (보조 작업)은 외부 데이터셋을 통한 pre-train이나 self-supervised learning일 수 있다.\nFeature Adaptation\nauxiliary task나 데이터셋을 통해 학습된 feature는 anomaly score를 매기기 전에 적응이 필요할 수 있다. 이는 훈련 데이터셋을 통한 fine-tuning으로, 적응된 feature extractor는 $\\psi$로 표기한다.\nAnomaly Scoring\nFeature를 적응시킨 후, 훈련 데이터셋 샘플들의 특성 $\\psi(x_1), \\psi(x_2), \\dots, \\psi(x_N)$ 을 추출한다. 그 다음, Anomaly score를 구하는 함수를 학습하는 과정을 진행한다. 일반적으로 scoring function은 테스트 샘플 $\\psi(x)$ 주변의 정상 데이터 밀도를 측정하며 밀도가 낮은 지역에 높은 anomaly score를 할당한다.\nDeep Nearest Neighbours (DN2) \u0026ldquo;Deep Nearest Neighbor Anomaly Detection\u0026rdquo;에서 제안된 방법으로, DN2에서는 ImageNet 데이터셋에서 pre-trained된 ResNet을 사용해 feature를 추출하고, kNN을 적용해 Normal과 Anomaly를 구분한다. (Normal과 Anomaly 이미지 간의 평균 거리를 Anomaly Score로 사용한다)\nSemantic Pyramid Anomaly Detection (SPADE) \u0026ldquo;Sub-Image Anomaly Detection with Deep Pyramid Correspondences\u0026rdquo;에서 제안된 방법으로, ImageNet으로 사전 훈련된 ResNet을 사용하여 모든 이미지에 대한 픽셀별 특성을 추출한다. 또한 Feature Pyramid를 이용하여 다양한 수준의 feature를 동시에 추출하고 concat해 사용한다. DN2와는 달리 SPADE에서는 Anomaly Segmentation도 가능하다.\nDeep Support Vector Data Description (DeepSVDD) \u0026ldquo;Deep One-Class Classification\u0026rdquo;에서 제안된 방법으로, 데이터의 정상적인 패턴을 학습하여 정상 범주에서 크게 벗어난 데이터 포인트를 Anomaly로 식별하는 것이다. CNN을 사용해 이미지 데이터를 저차원의 feature 공간으로 매핑하고, 데이터 포인트가 중심에서 얼마나 떨어져 있는지를 측정하여 Anomaly 여부를 판단한다.\nJoint Optimization (JO) \u0026ldquo;Learning Deep Features for One-Class Classification\u0026rdquo;에서 제안된 방법으로, ImageNet 데이터셋에서 객체 분류를 위해 Pretrained된 Feature Extractor를 사용한다. 오분류에 대한 패널티가 없는 경우 trivial한 솔루션을 학습할 수 있기에, compactness loss와 classification loss를 동시에 최적화한다. 이 방법은 메모리를 많이 요구하며, 두 작업을 함께 훈련하는 경우 Anomaly Detection 작업의 정확도가 떨어질 수 있다는 한계점을 가진다.\nMethod SVDD와 JO와 유사하게 compactness loss를 사용하여 pre-trained된 feature의 분포를 anomaly detection 작업에 적응시킨다. 하지만 구조를 제한하거나 외부 데이터를 사용하지 않고, 직접적으로 Catastrophic Collapse를 다룬다.\ncompactness loss의 최적 솔루션이 Collapse로 이어질 수 있다. Collapse가 일어나면 모든 입력을 같은 지점으로 매핑하게 되어, 더이상 구분이 불가능해진다.\n본 논문에서는 Catastrophic Collapse를 방지하기 위해 아래 3가지 방법을 제시하였다.\nSimple Early Stopping (PANDA-Early) collapse가 일어나기 전에, 특정 Epoch마다 Early Stopping을 진행하는 방법이다. 가장 단순하며 강력한 방법이지만, Hyperparameter의 설정이 필요하다는 단점이 있다. 예를 들어, 15 Epoch마다 early stopping을 진행하는 것이다.\nSample-Wise Early Stopping (PANDA-SES) sample 단위로 early stopping여부를 결정하는 방법이다. Anomaly 샘플과 중심 간의 거리가 멀고, 정상 샘플과 중심 간의 거리가 짧을 때 anomaly detection의 정확도가 상관관계가 있다. 이를 위해 훈련 과정 중 특정 Epoch마다 (예를 들어 5 Epoch 마다) 평균 거리를 저장하고, 정규화를 거치고 평균 거리의 최대 비율을 anomaly detection score로 사용한다.\nElastic Regularization (PANDA-EWC) Continual Learning은 adaptive regularization을 이용하는 방법이다.\ncontinual learning에서 영감을 받아 Elastic Weight Consolidation(EWC)을 사용한 방법이다. Continual Learning이란 이전에 학습한 것을 까먹지 않고 새로운 것을 학습하는 것이다. 여기서 보조 작업에 대해 사전 훈련을 진행하기 위해 100개의 미니배치를 사용한다. 이 과정에서 신경망의 모든 가중치 파라미터에 대한 Fisher 정보 행렬 $F$의 대각선을 계산한다. 이는 사전 훈련 단계가 끝난 후 한 번만 수행한다. 각 가중치 파라미터의 Fisher 행렬 값은 사전 훈련 데이터셋을 통해 주어진 식으로 계산된다.\n연구팀은 Fisher 정보 행렬의 대각선 요소를 사용하여 네트워크의 각 가중치가 사전 훈련된 상태($\\psi_0$)에서 미세 조정된 상태($\\psi^*$)로 변화하는 거리의 제곱을 가중치로 삼는다. 이는 가중치 함수의 손실 풍경 곡률을 측정하는 방법으로 볼 수 있으며, 값이 크면 곡률이 높고 가중치가 비탄력적임을 의미한다.\n이러한 정규화 방법은 $\\lambda$라는 하이퍼파라미터로 가중치가 부여된 compactness loss와 함께 사용된다. 본 연구에서는 $\\lambda = 10^4$를 사용했다. 이를 통해 최종적인 손실 함수를 정의하고, 이는 사전 훈련된 가중치와 미세 조정된 가중치 간의 차이를 기반으로 한다. 이 접근법은 네트워크가 새로운 작업을 학습하면서도 이전에 학습한 작업에 대한 정보를 유지할 수 있도록 돕는다.\nAnomaly Scoring 전통적인 Anomaly Detection와 같이, Anomaly Score는 밀도 추정을 통해 구할 수 있다. 따라서 본 연구에서도 kNN을 사용해 구현한다.\nOutlier Exposure Outlier Exposure는 이미지 이상 탐지 작업을 확장한 것으로, Normal 데이터보다 Anomaly에 더 유사한 Auxiliary 데이터셋 $D_{OE}$가 있다고 가정하고, 데이터셋을 Normal과 Abnormal로 분류한다. 이는 Linear Classification Layer $w$와 Feature $\\psi$를 이용해 Logistic Regression Loss를 계산하는 방식으로 이루어진다.\nExpreiments Dataset Dataset $N_{classes}$ $N_{train}$ $N_{test}$ CIFAR10 10 5,000 10,000 Fashion MNIST 10 6,000 10,000 CIFAR100 20 2,500 10,000 Flowers 102 10 7,169 Birds 200 30 5,794 CatsVsDogs 2 10,000 5,000 MVTec 15 242 1,725 WBC 4 59 62 DIOR 19 649 9,243 여기서 MVTec을 제외한 데이터셋은 정상 데이터를 한 개의 클래스로 구성하고, 나머지 클래스는 비정상으로 구성한다. 예를 들어, 고양이 이미지는 정상이고 강아지나 토끼 등 다른 이미지는 전부 비정상으로 구성된다.\nMVTec 데이터셋은 Anomaly Detection을 위해 제작된 데이터셋으로, 클래스마다 정상과 비정상 이미지가 라벨링되어 있다.\nResults 위 두 결과를 보았을 때, Self-Supervised 방법보다 DN2와 PANDA 방법이 훨씬 높은 성능을 보이는 것을 확인할 수 있다.\n기존의 Anomaly Segmentation 방법들보다 SPADE 방법이 매우 높은 성능을 보이는 것을 확인할 수 있다.\n위 표를 보면, 모든 데이터셋에서 PANDA 방법들이 JO 방법보다 높은 성능을 보이는 것을 확인할 수 있다.\nConclusion 본 논문에서는 Anomaly Detection과 Anomaly Aegmentation을 위한 간단한 baseline을 제안하였으며, 이 방법은 현재 SOTA 방법들을 능가하며, 한계점을 해결했다. 또한 pre-trained된 Feature을 적응시키고 Catastrophic Collapse를 완화하는 방법을 제안하였다.\n하지만 이 연구의 주요 한계점은 pre-trained된 강력한 Feature Extractor가 필요하다는 것이다.\n","date":"2023-12-27T00:00:00Z","image":"https://gyeongmin.kr/images/paper-review.png","permalink":"https://gyeongmin.kr/p/paper-review-panda/","title":"[논문리뷰] PANDA: Adapting Pretrained Features for Anomaly Detection and Segmentation"},{"content":"소수와 약수, 배수의 정의 소수는 영어로 prime 이라고 한다. 또한, $p$가 소수일 때 $p^k$를 prime power 라고 한다.\n정수 $a, b$가 있을 때 $a$가 $b$의 약수라는 것은 정수 $n$이 있어 $b=an$이라는 것이다. 이때 $b$를 $a$의 배수라고 한다.\n자연수 $p\\geq2$의 약수가 $1$과 $p$ 뿐이면, $p$를 소수라고 부른다.\n소수 판별 알고리즘 소수의 정의만 가지고 단순히 생각해 보자. 주어진 수 $N$을 $1$부터 $N$까지 나누어 보고, 나누어 떨어지는 수가 2개라면 소수이다.\n다르게 말한다면, $N$을 $2$부터 $N-1$까지의 수로 나누어 봤을 때 나누어 떨어지는 경우가 있으면 소수가 아니고, 나누어 떨어지는 경우가 없으면 소수라는 것이다.\n1 2 3 4 5 6 7 8 9 10 11 int isPrime(int n) { if (n \u0026lt; 2) { return false; } for (int i = 2; i \u0026lt; n; i++) { if (n % i == 0) { return false; } } return true; } 위 코드는 주어진 수가 소수인지 판별하는 c++ 코드이다. 2부터 검사하기에, 1이 들어오는 경우를 예외처리 해 주어야 한다.\n위 코드는 $2$부터 $N-1$ 까지의 모든 수를 계산해 본다. 따라서 시간복잡도는 $\\bigo(N)$이다.\n소수 판별 알고리즘 최적화 합성수 $N$에서 $1$을 제외한 가장 작은 약수를 $d$라고 하자. $\\frac{N}{d}$도 $1$이 아닌 $N$의 약수이므로, $d \\leq\\frac{N}{d}$ 이다. 우변의 $d$를 이항시키면 $d^2 \\leq N$이고, 둘 다 자연수이므로 $d \\leq \\sqrt{N}$이다.\n즉, 소수를 판별할 때 2부터 $\\sqrt{N}$ 까지만 검사 해 주어도 충분하다.\n반복문의 범위를 (int i = 2; i \u0026lt;= sqrt(n); i++)로 해도 괜찮지만, sqrt 함수는 실수연산이기에 오차가 발생할 수 있다. 따라서 for (int i = 2; i*i \u0026lt;= n; i++)으로 작성하는 것을 권장한다.\n1 2 3 4 5 6 7 8 9 10 11 int isPrime(int n) { if (n \u0026lt; 2) { return false; } for (int i = 2; i*i \u0026lt;= n; i++) { if (n % i == 0) { return false; } } return true; } 위 코드의 시간복잡도는 $\\bigo(\\sqrt{N})$이다.\n소수 판별 예제 문제 https://www.acmicpc.net/problem/1978\nhttps://www.acmicpc.net/problem/2581\n약수 구하기 알고리즘 소수 판별 알고리즘을 조금만 응용하면 약수를 구할 수 있다.\n$1$부터 $\\sqrt{n}$까지 나누어 떨어질 때마다 벡터에 약수를 넣어 주면 된다.\n자연수 $d$가 $n$의 약수라면, $n/d$ 역시 $n$의 약수라는 것을 잊지 말자. 이 때, $n=m^2$이 제곱수인 경우 $\\sqrt{n}=m$이 약수로 두 번 세지는 경우를 조심하자.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; v; for (int i = 1; i * i \u0026lt;= n; i++) { if (n % i == 0) { v.push_back(i); int d = n / i; if (i != d) v.push_back(d); } } sort(v.begin(), v.end()); cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;의 약수: \u0026#34;; for (int i : v) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } } $\\bigo(\\sqrt{N})$의 시간복잡도 내에 약수를 모두 구할 수 있다.\n약수를 구한 이후 정렬을 해 주고 있다. STL 정렬의 시간복잡도가 $\\bigo(NlogN)$이라는 것은 모두 알고 있을 것이다.\nlong long 범위 내 약수의 개수의 상한선은 $\\sqrt[3]{N}$개라고 어림짐작해볼 수 있다. 따라서 약수의 개수가 아무리 많아도 정렬에 쓰이는 시간복잡도는 $\\bigo(\\sqrt[3]{N}log({\\sqrt[3]{N}}))$이하이다.\n양수 범위에서 $\\sqrt[3]{N}log({\\sqrt[3]{N}}) \u0026lt;\\sqrt{N}$임이 자명하므로, 위 코드의 시간복잡도는 $\\bigo(\\sqrt{N})$이다.\n약수 구하기 알고리즘 최적화 위 코드를 조금만 개선하면 정렬을 할 필요가 없다.\nv.push_back(d); 대신 다른 벡터에 담아둔 뒤, 역순으로 넣어주면 정렬된 약수를 구할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; divisor; vector\u0026lt;int\u0026gt; tmp; for (int i = 1; i * i \u0026lt;= n; i++) { if (n % i == 0) { divisor.push_back(i); int d = n / i; if (i != d) tmp.push_back(d); } } divisor.insert(divisor.end(), tmp.rbegin(), tmp.rend()); cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;의 약수: \u0026#34;; for (int i : divisor) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } } 약수 구하기 예제 문제 https://www.acmicpc.net/problem/2501\nhttps://www.acmicpc.net/problem/9506\n범위 내 소수를 모두 구하는 알고리즘 기존 방법에서 반복문을 돌려 소수를 모두 찾으려 한다면, 범위가 조금만 커져도 시간초과가 뜰 것이다. 범위 내 소수를 모두 구해야 한다면, 에라토스테네스의 체를 활용하면 된다.\n에라토스테네스의 체 알고리즘과 최적화에 대해서는 여기를 참고하고, 이번에는 간단하게 코드만 보고 넘어가자.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 vector\u0026lt;int\u0026gt; findPrime(int max) { vector\u0026lt;int\u0026gt; prime; vector\u0026lt;bool\u0026gt; check(max + 1, false); prime.push_back(2); for (int t = 3; t \u0026lt;= max; t += 2) { if (!check[t]) { prime.push_back(t); for (int i = t * t; i \u0026lt;= max; i += t) { check[i] = true; } } } return prime; } 소인수 분해 알고리즘 여태까지 잘 따라왔다면, 소인수분해도 간단하게 할 수 있을 것이다. factorize 함수는 주어진 $N$을 효율적으로 소인수분해 하는 함수이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #define ull unsigned long long using namespace std; vector\u0026lt;ull\u0026gt; factorize(ull n) { vector\u0026lt;ull\u0026gt; factors; for (int i = 2; i * i \u0026lt;= n; i++) { while (n % i == 0) { factors.push_back(i); n /= i; } } if (n \u0026gt; 1) { factors.push_back(n); } return factors; } int main() { ull n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ull\u0026gt; factors = factorize(n); cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;의 소인수분해 : \u0026#34;; for (int i = 0; i \u0026lt; factors.size(); i++) { cout \u0026lt;\u0026lt; factors[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } if (factors.size() == 1) { cout \u0026lt;\u0026lt; \u0026#34;(소수)\u0026#34;; } } 번외 알고리즘 정수론 파트에는 어렵지만 재미있는 알고리즘들이 많다. 굳이 알 필요는 없지만, 번외로 준비해 봤다.\n폴라드 로 소인수분해 int 범위 까지는 괜찮은데, long long 범위의 수를 위 소인수분해 알고리즘으로 계산하면 TLE가 난다.\n이런 문제들은 범위가 $1 \\leq N \\leq 10^{18}$인데, 밀러-라빈 소수 판정법을 이용하여 폴라드 로 소인수분해 알고리즘을 구현하여 소인수분해한 후, DFS 등으로 약수를 구해주어야 한다.\n나중에 시간이 되면 위 알고리즘도 다룰 예정이다.\n소수 계량 함수 소수 계량 함수 $\\pi(n)$은 $n$ 이하의 소수 개수를 나타내는 함수이다. 이 함수에 대해 다음 식이 성립한다.\n$$\\pi(n) \\approx \\frac{n}{\\ln(n)}$$\n예를 들어 $\\pi(10^6)$의 근삿값은 $72382$고, 정확한 값은 $78498$이다.\n이 함수를 이용하면 소수의 개수와 관련된 문제에서 시간복잡도를 간접적으로 구할 수 있다.\n","date":"2023-12-03T00:00:00Z","image":"https://gyeongmin.kr/images/algorithm.png","permalink":"https://gyeongmin.kr/p/prime-number-and-divisors/","title":"소수 판별과 약수 구하기"},{"content":" 문제 링크 : https://www.acmicpc.net/problem/1331\n문제 나이트 투어는 체스판에서 나이트가 모든 칸을 정확히 한 번씩 방문하며, 마지막으로 방문하는 칸에서 시작점으로 돌아올 수 있는 경로이다. 다음 그림은 나이트 투어의 한 예이다.\n영식이는 6×6 체스판 위에서 또 다른 나이트 투어의 경로를 찾으려고 한다. 체스판의 한 칸은 A, B, C, D, E, F 중에서 하나와 1, 2, 3, 4, 5, 6 중에서 하나를 이어 붙인 것으로 나타낼 수 있다. 영식이의 나이트 투어 경로가 주어질 때, 이것이 올바른 것이면 Valid, 올바르지 않으면 Invalid를 출력하는 프로그램을 작성하시오.\n입력 36개의 줄에 나이트가 방문한 순서대로 입력이 주어진다. 체스판에 존재하는 칸만 입력으로 주어진다.\n출력 첫째 줄에 문제의 정답을 출력한다.\n풀이 두 지점에 대한 x와 y의 좌표 차이가 각각 2,1 또는 1,2면 나이트의 움직임과 같다. 마지막으로 방문하는 칸에서 시작점으로 돌아올 수 있어야 하기 때문에, 시작점과 끝점이 나이트의 움직임인지 검사한다. 모든 지점 $p$에 대해 반복하며, $p$와 그 다음 지점 $p+1$ 간의 움직임을 검사하고, 이미 방문한 지점을 또 방문하는지 검사한다. 모든 검사 조건을 통과하면 Valid이다. 소스 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef struct pos { int r, c; } pos; bool check[6][6]; vector\u0026lt;pos\u0026gt; v(36); bool is_knight_move(pos a, pos b) { bool ret = false; int dy = abs(a.r - b.r); int dx = abs(a.c - b.c); if (dy == 2 \u0026amp;\u0026amp; dx == 1) ret = true; if (dy == 1 \u0026amp;\u0026amp; dx == 2) ret = true; return ret; } string solve() { if (!is_knight_move(v.front(), v.back())) return \u0026#34;Invalid\u0026#34;; pos post = {-1, -1}; for (pos \u0026amp;now : v) { bool \u0026amp;visit = check[now.r][now.c]; if (visit) return \u0026#34;Invalid\u0026#34;; else visit = true; if (post.r != -1 \u0026amp;\u0026amp; !is_knight_move(now, post)) return \u0026#34;Invalid\u0026#34;; post = now; } return \u0026#34;Valid\u0026#34;; } int main() { ios::sync_with_stdio(false), cin.tie(nullptr); for (pos \u0026amp;p : v) { string s; cin \u0026gt;\u0026gt; s; p = {s[0] - \u0026#39;A\u0026#39;, s[1] - \u0026#39;1\u0026#39;}; } cout \u0026lt;\u0026lt; solve(); return 0; } ","date":"2023-11-30T00:00:00Z","image":"https://gyeongmin.kr/images/boj.png","permalink":"https://gyeongmin.kr/p/boj-1331/","title":"BOJ 1331: 나이트 투어 (C++)"},{"content":" 문제 링크 : https://www.acmicpc.net/problem/20437\n문제 작년에 이어 새로운 문자열 게임이 있다. 게임의 진행 방식은 아래와 같다.\n알파벳 소문자로 이루어진 문자열 $W$가 주어진다.\n양의 정수 $K$가 주어진다.\n어떤 문자를 정확히 $K$개를 포함하는 가장 짧은 연속 문자열의 길이를 구한다.\n어떤 문자를 정확히 $K$개를 포함하고, 문자열의 첫 번째와 마지막 글자가 해당 문자로 같은 가장 긴 연속 문자열의 길이를 구한다.\n위와 같은 방식으로 게임을 $T$회 진행한다.\n입력 문자열 게임의 수 $T$가 주어진다. $(1 ≤ T ≤ 100)$\n다음 줄부터 2개의 줄 동안 문자열 $W$와 정수 $K$가 주어진다. $(1 ≤ K ≤ |W| ≤ 10,000) $\n출력 $T$개의 줄 동안 문자열 게임의 3번과 4번에서 구한 연속 문자열의 길이를 공백을 사이에 두고 출력한다.\n만약 만족하는 연속 문자열이 없을 시 -1을 출력한다.\n풀이 인덱스 전처리 문자별로 인덱스를 전처리한다. 예를 들어, 문자열이 apple 이라면 아래와 같이 저장하면 된다.\nchar index a 0 p 1, 2 l 3 e 4 1 2 3 4 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; v((int) \u0026#39;z\u0026#39; + 1); for (int i = 0; i \u0026lt; s.length(); ++i) { v[s[i]].push_back(i); } 슬라이딩 윈도우 적용 인덱스들은 자연스럽게 정렬이 되어 있을 것이다.\n길이가 K인 슬라이딩 윈도우를 적용한다. a부터 z까지 인덱스가 저장된 벡터를 보면서, 문자가 K인 범위의 길이를 구해주자. start는 0부터 시작하고, end는 k-1 부터 시작하면 된다.\n문자가 K개 나오는 범위의 길이는 인덱스[end] - 인덱스[start] + 1 로 구할 수 있다.\n1 2 3 4 5 for (char c = \u0026#39;a\u0026#39;; c \u0026lt;= \u0026#39;z\u0026#39;; ++c) { for (int start = 0, end = k - 1; end \u0026lt; v[c].size(); ++end, ++start) { int length = v[c][end] - v[c][start] + 1; } } 아래와 같이 Range-based for loop을 사용해도 된다.\n1 2 3 4 5 for (auto indexes : v) { for (int start = 0, end = k - 1; end \u0026lt; indexes.size(); ++end, ++start) { int length = indexes[end] - indexes[start] + 1; } } 정답 출력 최대값과 최소값을 구한 후 출력해 주자. 이 때, min_len이 INT_MAX라는 것은 값을 찾지 못했다는 뜻이므로 -1을 출력한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int min_len = INT_MAX; int max_len = INT_MIN; for (auto indexes : v) { for (int start = 0, end = k - 1; end \u0026lt; indexes.size(); ++end, ++start) { int length = indexes[end] - indexes[start] + 1; min_len = min(min_len, length); max_len = max(max_len, length); } } if (min_len == INT_MAX) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; min_len \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; max_len \u0026lt;\u0026lt; endl; } 소스 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve() { string s; cin \u0026gt;\u0026gt; s; int k; cin \u0026gt;\u0026gt; k; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; v((int) \u0026#39;z\u0026#39; + 1); for (int i = 0; i \u0026lt; s.length(); ++i) { v[s[i]].push_back(i); } int min_len = INT_MAX; int max_len = INT_MIN; for (auto indexes : v) { for (int start = 0, end = k - 1; end \u0026lt; indexes.size(); ++end, ++start) { int length = indexes[end] - indexes[start] + 1; min_len = min(min_len, length); max_len = max(max_len, length); } } if (min_len == INT_MAX) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; min_len \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; max_len \u0026lt;\u0026lt; endl; } } int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ","date":"2023-07-07T00:00:00Z","image":"https://gyeongmin.kr/images/boj.png","permalink":"https://gyeongmin.kr/p/boj-20437/","title":"BOJ 20437: 문자열 게임 2 (C++)"},{"content":"A - N-choice question https://atcoder.jp/contests/abc300/tasks/abc300_a\n문제 첫째 줄에 배열의 길이 $N$과 두 수 $A$와 $B$가 주어진다. 둘째 줄에 배열이 주어진다.\n설명 배열 중에서 $A+B$와 일치하는 것의 인덱스를 출력한다.\n소스 코드 1 2 3 4 5 6 import sys input = sys.stdin.readline n, a, b = map(int, input().split()) arr = [int(x) for x in input().split()] print(arr.index(a+b)+1) C - Cross https://atcoder.jp/contests/abc300/tasks/abc300_c\n문제 첫째 줄에 배열의 높이 $H$와 너비 $W$가 주어진다. 둘째 줄부터 $1+H$ 번째 줄까지 배열이 주어진다.\n\u0026lsquo;#\u0026lsquo;이 크로스하는 경우를 세 주면 되는데, 사이즈별로 개수를 세 주어야 한다.\n1 2 3 4 5 #...# .#.#. ..#.. .#.#. #...# 위 경우는 사이즈가 2인 것이다.\n사이즈가 $1$인 개수부터 사이즈가 $N$인 개수까지 출력하면 된다. 여기서 $N$은 $min(H,W)$이다.\n해설 중심점을 먼저 찾으면 되는데, 모든 중심점은 두 가지 조건을 만족한다.\n모든 크로스의 중심점은 아래 에시의 형태이다. 1 2 3 #.# .#. #.# 모든 중심점의 좌표값은 다음 범위 내에 있다. $1 \\leq R \\leq H-2$ $1 \\leq C \\leq W-2$ 이걸로 중심점을 한 개씩 잡고, 1씩 크기를 늘려가면서 체크해주면 된다.\n소스 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import sys input = sys.stdin.readline def check(x, y): i = 1 while True: for dx, dy in zip([i, i, -i, -i], [i, -i, i, -i]): nx, ny = x + dx, y + dy if not nx in range(w) or not ny in range(h): return i-2 if arr[ny][nx] != \u0026#39;#\u0026#39;: return i-2 i += 1 h, w = map(int, input().split()) arr = [input().rstrip() for _ in range(h)] result = [0 for _ in range(min(h, w))] for y in range(1, h-1): for x in range(1, w-1): if arr[y][x] == arr[y-1][x-1] == arr[y-1][x+1] == arr[y+1][x-1] == arr[y+1][x+1] == \u0026#39;#\u0026#39;: result[check(x, y)] += 1 print(*result) D - AABCC https://atcoder.jp/contests/abc300/tasks/abc300_d\n문제 첫째 줄에 $N$이 주어진다. $(3 \\leq N \\leq 10^{12})$\n$N$보다 크지 않은 양의 정수 중에서, $a^2\\times b\\times c^2$ 로 표현될 수 있는 수의 개수를 출력한다. $(a\u0026lt;b\u0026lt;c)$ 이며, $a, b,c$는 소수이다.\n해설 재미있는 문제였다.\n$\\sqrt{N}$까지 소수를 구하고, $a\u0026lt;b\u0026lt;c$가 되도록 세 가지 소수를 선택해 조건을 만족하는지 개수를 세 주면 된다.\n커팅 없이 돌리면 시간 초과가 나고, 두 가지 커팅을 해 주어야 한다.\n$b \u0026lt; c$ 이므로 $a^2 \\times b^3$이 $N$ 보다 크다면 $a^2\\times b\\times c^2 \\leq N$을 만족할 수 없으므로, 그 뒤는 확인하지 않아도 된다.\n$a^2\\times b\\times c^2$ 가 $N$보다 크다면, 마찬가지로 그 뒤는 확인하지 않아도 된다.\n소스 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import sys from math import * input = sys.stdin.readline def eratosthenes(n): primes = [True] * (n + 1) p = 2 while p * p \u0026lt;= n: if primes[p]: for i in range(p * p, n + 1, p): primes[i] = False p += 1 primes_list = [] for p in range(2, n): if primes[p]: primes_list.append(p) return primes_list n = int(input()) primes = eratosthenes(floor(sqrt(n))) l = len(primes) count = 0 for i in range(l): for j in range(i+1, l): a, b = primes[i], primes[j] if a*a*b*b*b \u0026gt; n: break for k in range(j+1, l): a, b, c = primes[i], primes[j], primes[k] if a*a*b*c*c \u0026lt;= n: count += 1 else: break print(count) ","date":"2023-04-30T00:00:00Z","image":"https://gyeongmin.kr/images/atcoder.png","permalink":"https://gyeongmin.kr/p/abc-300/","title":"AtCoder ABC 300: A, C, D"},{"content":" 문제 링크 : https://www.acmicpc.net/problem/23807\n문제 서준이는 아빠로부터 생일선물로 세계 지도를 받아서 매우 기뻤다. 세계 지도에서 최단 경로를 찾는 프로그램을 개발해서 아빠께 감사의 마음을 전달하려고 한다. 세계 지도는 도시를 정점으로 갖고 도시 간의 도로를 간선으로 갖는 무방향성 그래프이며(undirected graph), 도로의 길이가 간선의 가중치이다. 출발 정점 $X$에서 출발해서 $P$개의 중간 정점 중 적어도 세 개의 정점을 반드시 거친 후 도착 정점 $Z$에 도달하는 최단 거리를 구해서 우리 서준이를 도와주자.\n입력 첫째 줄에 정점의 수 $N(10 \\leq N \\leq 100,000)$, 간선의 수 $M(10 \\leq M \\leq 300,000)$이 주어진다.\n다음 $M$개 줄에 간선 정보 $u, v, w$가 주어지며 도시 $u$와 도시 $v$ 사이의 가중치가 정수 $w$인 양방향 도로를 나타낸다. $(1 \\leq u, v \\leq N, u ≠ v, 1 \\leq w \\leq 1,000,000)$\n다음 줄에 $X Z$가 주어진다. $(1 \\leq X, Z \\leq N, X \\neq Z)$\n다음 줄에 $P$가 주어진다. $(3 \\leq P \\leq \\min(100, N - 3))$\n다음 줄에 $P$개의 서로 다른 중간 정점 $Y(1 \\leq Y \\leq N, X ≠ Y ≠ Z)$가 빈칸을 사이에 두고 주어진다.\n출력 출발 정점 $X$에서 출발해서 $P$개의 중간 정점 중 적어도 세 개의 정점을 반드시 거친 후 도착 정점 $Z$에 도달하는 최단 거리를 출력한다. 도착 정점 Z에 도착할 수 없는 경우 $-1$을 출력한다.\n풀이 브루트포스 + 다익스트라 문제이다.\n$X - A - B - C - Z$ 로 가는 최단 거리를 찾아야 한다.\n우선순위 큐를 활용한 다익스트라의 시간복잡도는 $bigo(E\\log{V})$이다. 중간 정점은 최대 100개가 주어지며, 이 중 3개를 선택해야 하므로 경우의 수가 최대 ${}_{100}{\\rm P}_3$ 이다. 모든 경우에서 다익스트라를 돌리면 당연히 시간초과가 난다.\n$X$와 중간 정점들을 기준으로 다익스트라를 먼저 돌리고, 그 결과들을 활용해 모든 경우 중 최소 거리를 구해 주면 된다.\n다익스트라를 최대 101번 돌리고, ${}_{100}{\\rm P}_3 = 970,200$이다. 종합하여 시간 복잡도를 계산해 보면 $300,000\\times\\log{100,000} \\times 101 + 970,200 = 152,470,200$ 가 나온다.\n이 문제의 시간 제한은 6초이다. 바로 통과할 줄 알았다. 하지만 우리의 파이썬은 생각보다 느리다.\npython3 말고 pypy3로 제출해야 한다. 다익스트라 결과를 저장할 dist를 리스트가 아닌 딕셔너리로 구현하고, min() 함수 대신 직접 if문으로 최소값을 찾는 등 최적화를 조금 진행해 주어야 겨우 풀린다.\n마지막에 결과값이 INF일 땐 -1로 출력하는 것을 잊지 말자.\n소스 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 from heapq import heappop, heappush from itertools import permutations import sys input = sys.stdin.readline INF = float(\u0026#39;inf\u0026#39;) def dijkstra(graph, start): n = len(graph) dist = [INF] * n dist[start] = 0 queue = [(0, start)] while queue: path_len, v = heappop(queue) if path_len == dist[v]: for w, edge_len in graph[v]: if edge_len + path_len \u0026lt; dist[w]: dist[w] = edge_len + path_len heappush(queue, (edge_len + path_len, w)) return dist n, m = map(int, input().split()) graph = [[] for _ in range(n+1)] for _ in range(m): u, v, w = map(int, input().split()) graph[u].append((v, w)) graph[v].append((u, w)) x, z = map(int, input().split()) p = int(input()) mid = [int(x) for x in input().split()] dist = {} for node in mid: dist[node] = dijkstra(graph, node) dist[x] = dijkstra(graph, x) result = INF for a, b, c in permutations(mid, 3): total = dist[x][a] + dist[a][b] + dist[b][c] + dist[c][z] if result \u0026gt; total: result = total if result == INF: result = -1 print(result) 후기 파이썬 기준 시간 제한이 정말 빡빡한 문제였다. 이 문제를 파이썬으로 풀어본 사람이 없길래 파이썬으로 풀어 봤다.\n","date":"2023-04-21T00:00:00Z","image":"https://gyeongmin.kr/images/boj.png","permalink":"https://gyeongmin.kr/p/boj-23807/","title":"BOJ 23807: 두 단계 최단 경로 3 (Python)"},{"content":" 문제 링크 : https://www.acmicpc.net/problem/16935\n문제 크기가 N×M인 배열이 있을 때, 배열에 연산을 R번 적용하려고 한다. 연산은 총 6가지가 있다.\n1번 연산은 배열을 상하 반전시키는 연산이다.\n1 2 3 4 5 6 7 1 6 2 9 8 4 → 4 2 9 3 1 8 7 2 6 9 8 2 → 9 2 3 6 1 5 1 8 3 4 2 9 → 7 4 6 2 3 1 7 4 6 2 3 1 → 1 8 3 4 2 9 9 2 3 6 1 5 → 7 2 6 9 8 2 4 2 9 3 1 8 → 1 6 2 9 8 4 \u0026lt;배열\u0026gt; \u0026lt;연산 결과\u0026gt; 2번 연산은 배열을 좌우 반전시키는 연산이다.\n1 2 3 4 5 6 7 1 6 2 9 8 4 → 4 8 9 2 6 1 7 2 6 9 8 2 → 2 8 9 6 2 7 1 8 3 4 2 9 → 9 2 4 3 8 1 7 4 6 2 3 1 → 1 3 2 6 4 7 9 2 3 6 1 5 → 5 1 6 3 2 9 4 2 9 3 1 8 → 8 1 3 9 2 4 \u0026lt;배열\u0026gt; \u0026lt;연산 결과\u0026gt; 3번 연산은 오른쪽으로 90도 회전시키는 연산이다.\n1 2 3 4 5 6 7 1 6 2 9 8 4 → 4 9 7 1 7 1 7 2 6 9 8 2 → 2 2 4 8 2 6 1 8 3 4 2 9 → 9 3 6 3 6 2 7 4 6 2 3 1 → 3 6 2 4 9 9 9 2 3 6 1 5 → 1 1 3 2 8 8 4 2 9 3 1 8 → 8 5 1 9 2 4 \u0026lt;배열\u0026gt; \u0026lt;연산 결과\u0026gt; 4번 연산은 왼쪽으로 90도 회전시키는 연산이다.\n1 2 3 4 5 6 7 1 6 2 9 8 4 → 4 2 9 1 5 8 7 2 6 9 8 2 → 8 8 2 3 1 1 1 8 3 4 2 9 → 9 9 4 2 6 3 7 4 6 2 3 1 → 2 6 3 6 3 9 9 2 3 6 1 5 → 6 2 8 4 2 2 4 2 9 3 1 8 → 1 7 1 7 9 4 \u0026lt;배열\u0026gt; \u0026lt;연산 결과\u0026gt; 5, 6번 연산을 수행하려면 배열을 크기가 N/2×M/2인 4개의 부분 배열로 나눠야 한다. 아래 그림은 크기가 6×8인 배열을 4개의 그룹으로 나눈 것이고, 1부터 4까지의 수로 나타냈다.\n1 2 3 4 5 6 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 4 4 4 4 3 3 3 3 4 4 4 4 3 3 3 3 4 4 4 4 3 3 3 3 5번 연산은 1번 그룹의 부분 배열을 2번 그룹 위치로, 2번을 3번으로, 3번을 4번으로, 4번을 1번으로 이동시키는 연산이다.\n1 2 3 4 5 6 7 3 2 6 3 1 2 9 7 → 2 1 3 8 3 2 6 3 9 7 8 2 1 4 5 3 → 1 3 2 8 9 7 8 2 5 9 2 1 9 6 1 8 → 4 5 1 9 5 9 2 1 2 1 3 8 6 3 9 2 → 6 3 9 2 1 2 9 7 1 3 2 8 7 9 2 1 → 7 9 2 1 1 4 5 3 4 5 1 9 8 2 1 3 → 8 2 1 3 9 6 1 8 \u0026lt;배열\u0026gt; \u0026lt;연산 결과\u0026gt; 6번 연산은 1번 그룹의 부분 배열을 4번 그룹 위치로, 4번을 3번으로, 3번을 2번으로, 2번을 1번으로 이동시키는 연산이다.\n1 2 3 4 5 6 7 3 2 6 3 1 2 9 7 → 1 2 9 7 6 3 9 2 9 7 8 2 1 4 5 3 → 1 4 5 3 7 9 2 1 5 9 2 1 9 6 1 8 → 9 6 1 8 8 2 1 3 2 1 3 8 6 3 9 2 → 3 2 6 3 2 1 3 8 1 3 2 8 7 9 2 1 → 9 7 8 2 1 3 2 8 4 5 1 9 8 2 1 3 → 5 9 2 1 4 5 1 9 \u0026lt;배열\u0026gt; \u0026lt;연산 결과\u0026gt; 입력 첫째 줄에 배열의 크기 $N$, $M$과 수행해야 하는 연산의 수 R이 주어진다.\n둘째 줄부터 $N$개의 줄에 배열 $A$의 원소 $A_{ij}$가 주어진다.\n마지막 줄에는 수행해야 하는 연산이 주어진다. 연산은 공백으로 구분되어져 있고, 문제에서 설명한 연산 번호이며, 순서대로 적용시켜야 한다.\n출력 입력으로 주어진 배열에 $R$개의 연산을 순서대로 수행한 결과를 출력한다.\n제한 $2 \\leq N, M \\leq 100$ $1 \\leq R \\leq 1,000$ $N$, $M$은 짝수 $1 \\leq A_{ij} \\leq 10^8$ 소스 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import sys input = sys.stdin.readline n, m, r = map(int, input().split()) arr = [[int(x) for x in input().split()] for _ in range(n)] options = [int(x) for x in input().split()] for option in options: if option == 1: arr = arr[::-1] # 상하 반전 elif option == 2: arr = list(map(lambda x: x[::-1], arr)) # 좌우 반전 elif option == 3: arr = list(zip(*arr[::-1])) # 오른쪽으로 90도 회전 n, m = m, n # 행, 열 사이즈 스왑 elif option == 4: arr = list(map(list, zip(*arr)))[::-1] # 왼쪽으로 90도 회전 n, m = m, n else: arr1 = map(lambda x: x[:m//2], arr[:n//2]) # 1사분면 arr2 = map(lambda x: x[m//2:], arr[:n//2]) # 2사분면 arr3 = map(lambda x: x[:m//2], arr[n//2:]) # 3사분면 arr4 = map(lambda x: x[m//2:], arr[n//2:]) # 4사분면 if option == 5: # 시계 방향 사분면 회전 arr = list(zip(arr3, arr1)) + list(zip(arr4, arr2)) elif option == 6: # 반시계 방향 사분면 회전 arr = list(zip(arr2, arr4)) + list(zip(arr1, arr3)) arr = list(map(lambda x: x[0]+x[1], arr)) for row in arr: print(*row) 풀이 후기 좀 귀찮은 문제였는데, 깔끔하게 구현해 보려고 노력했다. 파이썬 리스트컴프리헨션을 연습하기 좋은 문제였다.\n","date":"2023-02-06T00:00:00Z","image":"https://gyeongmin.kr/images/boj.png","permalink":"https://gyeongmin.kr/p/boj-16935/","title":"16935번 : 배열 돌리기 3 (Python)"},{"content":" 문제 링크 : https://www.acmicpc.net/problem/14620\n문제 2017년 4월 5일 식목일을 맞이한 진아는 나무를 심는 대신 하이테크관 앞 화단에 꽃을 심어 등교할 때 마다 꽃길을 걷고 싶었다.\n진아가 가진 꽃의 씨앗은 꽃을 심고나면 정확히 1년후에 꽃이 피므로 진아는 다음해 식목일 부터 꽃길을 걸을 수 있다.\n하지만 진아에게는 꽃의 씨앗이 세개밖에 없었으므로 세 개의 꽃이 하나도 죽지 않고 1년후에 꽃잎이 만개하길 원한다.\n꽃밭은 N $\\times$ N의 격자 모양이고 진아는 씨앗을 (1,1)~(N,N)의 지점 중 한곳에 심을 수 있다. 꽃의 씨앗은 그림 (a)처럼 심어지며 1년 후 꽃이 피면 그림 (b)모양이 된다.\n꽃을 심을 때는 주의할 점이있다. 어떤 씨앗이 꽃이 핀 뒤 다른 꽃잎(혹은 꽃술)과 닿게 될 경우 두 꽃 모두 죽어버린다. 또 화단 밖으로 꽃잎이 나가게 된다면 그 꽃은 죽어버리고 만다.\n그림(c)는 세 꽃이 정상적으로 핀 모양이고 그림(d)는 두 꽃이 죽어버린 모양이다.\n하이테크 앞 화단의 대여 가격은 격자의 한 점마다 다르기 때문에 진아는 서로 다른 세 씨앗을 모두 꽃이 피게하면서 가장 싼 가격에 화단을 대여하고 싶다.\n단 화단을 대여할 때는 꽃잎이 핀 모양을 기준으로 대여를 해야하므로 꽃 하나당 5평의 땅을 대여해야만 한다.\n돈이 많지 않은 진아를 위하여 진아가 꽃을 심기 위해 필요한 최소비용을 구해주자!\n입력 입력의 첫째 줄에 화단의 한 변의 길이 $N (6 \\leq N \\leq 10)$이 들어온다.\n이후 N개의 줄에 N개씩 화단의 지점당 가격$(0 \\leq G \\leq 200)$이 주어진다.\n출력 꽃을 심기 위한 최소 비용을 출력한다.\n풀이 꽃이 + 모양으로 생겼기 때문에, 중심점을 잘 생각해야 한다.\n다음 그림을 보면서 꽃이 죽는 규칙을 살펴보자.\n중심점의 좌표 $(x,y)$는 $1 \\leq x, \\space y \\leq n-2$ 이다.\n두 꽃이 서로 겹쳐 죽는 경우는 다음 3가지다.\n$x_1, x_2$의 차가 $0$인 경우, $y_1, y_2$의 차이가 $3$미만일 때\n$x_1, x_2$의 차가 $1$인 경우, $y_1, y_2$의 차이가 $2$미만일 때\n$x_1, x_2$의 차가 $2$인 경우, $y_1, y_2$의 차이가 $1$미만일 때\n소스코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import sys from itertools import combinations input = sys.stdin.readline inf = int(2e9) def is_dead(p1, p2): if abs(p1[0] - p2[0]) == 0: if abs(p1[1] - p2[1]) \u0026lt; 3: return True elif abs(p1[0] - p2[0]) == 1: if abs(p1[1] - p2[1]) \u0026lt; 2: return True elif abs(p1[0] - p2[0]) == 2: if abs(p1[1] - p2[1]) \u0026lt; 1: return True return False def get_cost(p): x, y = p return cost[y][x] + cost[y-1][x] + cost[y+1][x] + cost[y][x-1] + cost[y][x+1] def solution(p1, p2, p3): if is_dead(p1, p2) or is_dead(p2, p3) or is_dead(p3, p1): return inf return get_cost(p1) + get_cost(p2) + get_cost(p3) n = int(input()) cost = [[int(x) for x in input().split()] for _ in range(n)] pos = [(x, y) for x in range(1, n-1) for y in range(1, n-1)] result = inf for p1, p2, p3 in combinations(pos, 3): result = min(result, solution(p1, p2, p3)) print(result) ","date":"2023-02-01T00:00:00Z","image":"https://gyeongmin.kr/images/boj.png","permalink":"https://gyeongmin.kr/p/boj-14620/","title":"BOJ 14620: 꽃길 (Python)"},{"content":" 문제 링크 : https://www.acmicpc.net/problem/9461\n문제 오른쪽 그림과 같이 삼각형이 나선 모양으로 놓여져 있다. 첫 삼각형은 정삼각형으로 변의 길이는 1이다. 그 다음에는 다음과 같은 과정으로 정삼각형을 계속 추가한다. 나선에서 가장 긴 변의 길이를 k라 했을 때, 그 변에 길이가 k인 정삼각형을 추가한다.\n파도반 수열 P(N)은 나선에 있는 정삼각형의 변의 길이이다. P(1)부터 P(10)까지 첫 10개 숫자는 1, 1, 1, 2, 2, 3, 4, 5, 7, 9이다.\nN이 주어졌을 때, P(N)을 구하는 프로그램을 작성하시오.\n입력 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. $(1 \\leq N \\leq 100)$\n출력 각 테스트 케이스마다 P(N)을 출력한다.\n풀이 $N$의 범위는 $(1 \\leq N \\leq 100)$ 이므로, 100까지 미리 계산해 두고 꺼내 쓰면 된다.\n조금만 찾아보면 규칙이 보이는데, $a_i$는 $a_{i-5}$와 $a_{i-1}$를 더한 값이다.\n다음 코드와 같이, 파이썬을 사용하면 배열의 특정 부분에 값을 편하게 넣어줄 수 있다.\n1 dp[1:10] = 1, 1, 1, 2, 2, 3, 4, 5, 7, 9 소스코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import sys input = sys.stdin.readline dp = [0 for _ in range(100)] dp[1:10] = 1, 1, 1, 2, 2, 3, 4, 5, 7, 9 for i in range(11, 101): dp[i] = dp[i-5] + dp[i-1] t = int(input()) for _ in range(t): n = int(input()) print(dp[n]) ","date":"2023-01-17T00:00:00Z","image":"https://gyeongmin.kr/images/boj.png","permalink":"https://gyeongmin.kr/p/boj-9461/","title":"BOJ 9461: 파도반 수열 (Python)"},{"content":"백준 디스코드 봇 \u0026lsquo;백준봇\u0026rsquo; 백준 스터디를 진행할 때 문제를 조금 더 이쁘게 올려 보고 싶어 만들었습니다.\nsolved.ac 비공식 API 를 사용하여 만들었습니다.\n사용 방법 문제 올리기 /백준 문제번호 로 문제를 올릴 수 있습니다. 또는 /백준 문제링크 로 문제를 올릴 수 있습니다. 문제와 소스코드를 함께 올리기 /백준 문제번호 또는 /백준 문제링크 하단에 소스코드를 같이 입력하면, 문제와 소스코드를 함께 올릴 수 있습니다.\n줄바꿈은 Shift + Enter 키를 눌러주시면 됩니다.\n위 사진과 같이 디스코드의 코드 블럭을 이용하시면, 하이라이팅된 코드를 업로드 할 수 있습니다.\n소스 코드가 길 때 디스코드의 Embed의 내용은 4096자 제한이 있습니다. 따라서 Embed의 범위를 벗어나면 아래 사진과 같이 출력합니다.\n명령어 입력이 잘못된 경우, \u0026ldquo;잘못된 입력입니다.\u0026rdquo; 라는 메세지를 출력합니다.\nEmbed에 실패하여 메세지를 보내지 못한 경우, 또는 solved.ac 서버가 불안정하여 데이터를 가져오지 못한 경우 \u0026ldquo;메세지 전송이 실패했습니다.\u0026rdquo; 라는 메세지를 출력합니다.\n백준봇 초대하기 초대 링크\n현재 너무 바빠 업데이트를 못 하고 있는데, 추후 다양한 기능을 업데이트할 예정입니다.\n","date":"2023-01-03T00:00:00Z","image":"https://gyeongmin.kr/p/baekjoonbot/image-1_hu3ba0e11ccd78cd419cf9cf4dfafe4b05_113858_120x120_fill_box_smart1_3.png","permalink":"https://gyeongmin.kr/p/baekjoonbot/","title":"백준 디스코드 봇 '백준봇'"},{"content":" 문제 링크 : https://www.acmicpc.net/problem/1011\n문제 우현이는 어린 시절, 지구 외의 다른 행성에서도 인류들이 살아갈 수 있는 미래가 오리라 믿었다. 그리고 그가 지구라는 세상에 발을 내려 놓은 지 23년이 지난 지금, 세계 최연소 ASNA 우주 비행사가 되어 새로운 세계에 발을 내려 놓는 영광의 순간을 기다리고 있다.\n그가 탑승하게 될 우주선은 Alpha Centauri라는 새로운 인류의 보금자리를 개척하기 위한 대규모 생활 유지 시스템을 탑재하고 있기 때문에, 그 크기와 질량이 엄청난 이유로 최신기술력을 총 동원하여 개발한 공간이동 장치를 탑재하였다. 하지만 이 공간이동 장치는 이동 거리를 급격하게 늘릴 경우 기계에 심각한 결함이 발생하는 단점이 있어서, 이전 작동시기에 k광년을 이동하였을 때는 $k-1$ , $k$ 혹은 $k+1$ 광년만을 다시 이동할 수 있다. 예를 들어, 이 장치를 처음 작동시킬 경우 -1 , 0 , 1 광년을 이론상 이동할 수 있으나 사실상 음수 혹은 0 거리만큼의 이동은 의미가 없으므로 1 광년을 이동할 수 있으며, 그 다음에는 0 , 1 , 2 광년을 이동할 수 있는 것이다. ( 여기서 다시 2광년을 이동한다면 다음 시기엔 1, 2, 3 광년을 이동할 수 있다. )\n김우현은 공간이동 장치 작동시의 에너지 소모가 크다는 점을 잘 알고 있기 때문에 $x$지점에서 $y$지점을 향해 최소한의 작동 횟수로 이동하려 한다. 하지만 $y$지점에 도착해서도 공간 이동장치의 안전성을 위하여 $y$지점에 도착하기 바로 직전의 이동거리는 반드시 1광년으로 하려 한다.\n김우현을 위해 $x$지점부터 정확히 $y$지점으로 이동하는데 필요한 공간 이동 장치 작동 횟수의 최솟값을 구하는 프로그램을 작성하라.\n입력 입력의 첫 줄에는 테스트케이스의 개수 $T$가 주어진다. 각각의 테스트 케이스에 대해 현재 위치 $x$ 와 목표 위치 $y$ 가 정수로 주어지며, $x$는 항상 $y$보다 작은 값을 갖는다. $(0 ≤ x \u0026lt; y \u0026lt; 231)$\n출력 각 테스트 케이스에 대해 $x$지점으로부터 $y$지점까지 정확히 도달하는데 필요한 최소한의 공간이동 장치 작동 횟수를 출력한다.\n풀이 우선 거리 $d$를 구한다. $d = y - x$\n그리고 $d$보다 작은 최대의 제곱수 $k^2$를 구한다.\n거리가 제곱수일 때에 주목하여 규칙을 살펴보자.\nk 거리 이동 횟수 1 1 1 1 1 2 11 2 1 3 111 3 2 4 121 3 2 5 1211 4 2 6 1221 4 2 7 12211 5 2 8 12221 5 3 9 12321 5 3 10 123211 6 3 11 123221 6 3 12 123321 6 3 13 1233211 7 3 14 1233221 7 3 15 1233321 7 4 16 1234321 7 보다시피 제곱수일 때 이동을 살펴보면\n$$1,2,3,\u0026hellip;,k,\u0026hellip;,3,2,1$$\n1부터 k까지 1씩 증가하고, 다시 1까지 감소하는 것을 확인할 수 있다.\n이때, 이동 거리가 제곱수인 경우 이동 횟수의 일반항을 구할 수 있다.\n$$a_{n} = 2n-1$$\n거리가 제곱수인 경우를 이용해서 이외의 경우도 구할 수 있다.\n$d - k^2\u0026lt;k$ 인 경우, 이동 거리는 거리가 $k^2$일 때 횟수에 1을 더한 값이다.\n$d - k^2\u0026lt;2k$ 인 경우, 이동 거리는 거리가 $k^2$일 때 횟수에 2을 더한 값이다.\n이를 수식화하면 $2 * k - 1 + [(d - k^2 + k - 1) / k]$ 가 된다.\n파이썬 코드로는 2 * k - 1 + (d - k ** 2 + k - 1) // k 가 된다.\n소스 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 n = int(input()) for _ in range(n): x, y = map(int, input().split()) d = y - x # d보다 작은 최대의 제곱수 k^2 k = 0 while k ** 2 \u0026lt;= d: k += 1 k -= 1 result = 2 * k - 1 + (d - k ** 2 + k - 1) // k print(result) ","date":"2022-06-30T00:00:00Z","image":"https://gyeongmin.kr/images/boj.png","permalink":"https://gyeongmin.kr/p/boj-1011/","title":"BOJ 1011: Fly me to the Alpha Centauri (Python)"},{"content":"윈도우 패키지 매니저 Chocolatey 컴퓨터를 포맷한 후 초기 설정할 때 유용하게 사용중인 프로그램이다.\n여태 프로그램을 설치하기 위해선 프로그램을 검색한 후, 사이트에 들어가서 설치 파일을 다운받은 후, 설치 파일을 실행시켜 일일히 Next를 눌러 가며 설치해야 했다.\nChocolatey를 사용하면 이 과정을 choco install python -y 와 같이 명령어 한 줄로 설치할 수 있다.\n미리 설치 명령어가 담긴 배치 파일을 만들어 둔다면, 포맷 후 한번에 모든 프로그램을 설치할 수 있다.\nchoco upgrade all 명령어를 사용하면 모든 프로그램을 업데이트할 수 있다.\n설치 방법 공식 홈페이지에서 설치 커맨드를 복사한다.\n윈도우 + X 키 를 눌러 Windows 터미널(Windows PowerShell)을 관리자 모드로 열어준 후, 복사한 커맨드를 붙여넣기한 후 엔터를 눌러주면 설치가 진행된다.\n사용 방법 여기서 설치하고 싶은 패키지를 검색한다.\n커맨드를 복사한 후, Windows PowerShell에서 커맨드를 실행한다. 조금만 기다리면 패키지가 설치된다.\n커맨드 패키지 검색 choco search 패키지명\n패키지 설치 choco install 패키지명\n패키지 설치 (프롬프트/버전 포함) choco install -y 패키지명 --version 버전\n설치된 패키지 버전 업그레이드 choco upgrade 패키지명\n패키지 상세 정보 choco info 패키지명\n설치된 패키지 확인 choco list -l\n설치된 패키지 삭제 choco uninstall 패키지명\nchocolatey 버전 업그레이드 choco upgrade chocolatey Chocolatey와 패키지를 한번에 설치하는 스크립트 아래 소스 코드는 본 작성자가 사용하고 있는 스크립트인데, 아래 주석 부분을 수정해서 사용하면 된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 @echo off CLS ECHO ************************************** ECHO * Start Chocolatey Batch ECHO ************************************** NET FILE 1\u0026gt;NUL 2\u0026gt;NUL if \u0026#39;%errorlevel%\u0026#39; == \u0026#39;0\u0026#39; ( goto gotPrivileges ) else ( goto getPrivileges ) :getPrivileges if \u0026#39;%1\u0026#39;==\u0026#39;ELEV\u0026#39; (shift \u0026amp; goto gotPrivileges) ECHO. ECHO ************************************** ECHO * Use UAC, switch to admin ECHO ************************************** setlocal DisableDelayedExpansion set \u0026#34;batchPath=%~0\u0026#34; setlocal EnableDelayedExpansion ECHO Set UAC = CreateObject^(\u0026#34;Shell.Application\u0026#34;^) \u0026gt; \u0026#34;%temp%\\OEgetPrivileges.vbs\u0026#34; ECHO UAC.ShellExecute \u0026#34;!batchPath!\u0026#34;, \u0026#34;ELEV\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;runas\u0026#34;, 1 \u0026gt;\u0026gt; \u0026#34;%temp%\\OEgetPrivileges.vbs\u0026#34; \u0026#34;%temp%\\OEgetPrivileges.vbs\u0026#34; exit /B :gotPrivileges setlocal \u0026amp; pushd . WHERE choco 1\u0026gt;NUL 2\u0026gt;NUL if \u0026#39;%errorlevel%\u0026#39; == \u0026#39;0\u0026#39; ( goto chocoInstalled ) else ( goto chocoMissing ) :chocoMissing ECHO. choice /M \u0026#34;Chocolatey not found. Install now?\u0026#34; IF \u0026#39;%errorlevel%\u0026#39; == \u0026#39;2\u0026#39; exit /B ECHO. ECHO ************************************** ECHO * Chocolatey install ECHO ************************************** @powershell -NoProfile -ExecutionPolicy Bypass -Command \u0026#34;iex ((new-object net.webclient).DownloadString(\u0026#39;https://chocolatey.org/install.ps1\u0026#39;))\u0026#34; \u0026amp;\u0026amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin :chocoInstalled ECHO. ECHO ************************************** ECHO * Packages install ECHO ************************************** @echo on choco feature enable --name=allowGlobalConfirmation choco upgrade all -y :::::::::::::::::::::::: 아래 부분을 변경 :::::::::::::::::::::::: :: 설치할 어플리케이션 목록 set choco_install=choco install -fy %choco_install% bandizip %choco_install% everything %choco_install% raidrive %choco_install% discord %choco_install% notion %choco_install% zoom %choco_install% slack %choco_install% git %choco_install% github-desktop %choco_install% vscode %choco_install% qbittorrent %choco_install% obs-studio %choco_install% steam %choco_install% leagueoflegends :: chocolatey에 없는 프로그램들 다운로드 링크 링크 열기 start explorer https://www.jetbrains.com/ko-kr/toolbox-app/download/download-thanks.html?platform=windows start explorer https://app-pc.kakaocdn.net/talk/win32/KakaoTalk_Setup.exe start explorer https://download01.logi.com/web/ftp/pub/techsupport/gaming/lghub_installer.exe start explorer https://anydesk.com/ko/downloads/thank-you?dv=win_exe start explorer https://visualstudio.microsoft.com/ko/ ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: choco feature disable --name=allowGlobalConfirmation RefreshEnv.cmd pause ","date":"2022-01-15T00:00:00Z","image":"https://gyeongmin.kr/p/chocolatey/image_hu626c632ff351f32c14b2e58c83a851de_69786_120x120_fill_box_smart1_3.png","permalink":"https://gyeongmin.kr/p/chocolatey/","title":"윈도우 패키지 매니저 Chocolatey"},{"content":"C언어로 만드는 리듬게임 1학년 텀프로젝트 과제로 만들었던 리듬게임입니다.\n리듬게임 자체를 만드는건 오래 걸리지 않았던 것 같은데, 노트들의 싱크를 맞춘다고 정말 고생했던 기억이 납니다.\n사용법 D, F, J, K 키를 사용하여 노트를 입력합니다.\n정확하게 노트를 입력하면 Excellent, 조금 느리게 입력하면 Good 판정이 됩니다.\n연속으로 노트를 입력하게 되면 콤보가 쌓입니다.\n콤보와 판정을 통해 점수가 쌓입니다. 점수 계산 식은 다음과 같습니다.\n1 score += (combo / 10 + 1) * 50 설정 메뉴에서 두가지 옵션을 켜고 끌 수 있습니다.\n\u0026lsquo;노트 찍기 모드\u0026rsquo;를 켜면 에디터 모드가 활성화 됩니다. 노래는 나오지만 노트는 내려오지 않습니다. 이 때, 노래에 맞춰 키보드를 입력하면 노트가 \u0026rsquo;note.txt\u0026rsquo; 파일에 저장되게 됩니다.\n\u0026lsquo;디버깅 모드\u0026rsquo;를 켜면 디버깅 모드가 활성화 됩니다. 화면이 새로고침 되는 딜레이를 확인할 수 있습니다.\n설명 시작 부분의 간단한 텍스트 애니메이션은 for문을 통해 구현하였습니다. 이차원 char 배열로 텍스트를 저장해둔 뒤, 한 줄씩 출력/지우기를 반복하는 방식입니다.\n노래를 선택하게 되면 노트가 저장된 텍스트 파일에서 char 배열로 버퍼를 받습니다. 0이면 노트가 없는 것이고, 1이면 노트가 있는 것으로 판단합니다.\n노래는 PlaySound 함수를 사용하여 재생하였습니다.\n노트는 텍스트 색상을 바꾼 뒤, 공백을 출력하여 리듬게임의 노트인 것처럼 구현하였습니다. SetConsoleTextAttribute 함수를 통해 텍스트의 색상을 바꾸어 주었습니다.\n한 화면의 딜레이는 노래의 BPM에 맞춰주었습니다. 노트가 빠르게 출력되어야 하기에 필연적으로 딜레이에 편차가 생기게 됩니다. 반복문의 시작과 끝에 시간을 측정하여, 딜레이를 균일하게 보정해 주었습니다.\n더블 버퍼링을 응용하여 프론트 버퍼와 백 버퍼가 바뀌는 부분만 공백으로 지운 후, 출력하는 방식으로 구현하였습니다.\n키 입력을 받는 것은 GetAsyncKeyState 함수를 사용하였습니다. 멀티 쓰레드를 위해 _beginthreadex 함수를 사용하였습니다. 여러 키를 동시에 입력받을 수 있게 해 줍니다.\n판정선에 노트가 들어왔을 때, 화면 버퍼와 키 입력 상태를 비교하여 노트 입력 판정을 구분합니다. 프론트 버퍼와 백 버퍼의 상태를 비교하여 롱 노트와 숏 노트를 구분합니다. 노트를 정확하게 눌렀다면 Excellent, 빠르게 눌렀다면 Good, 놓쳤다면 Miss로 구분합니다. key_state 변수를 만들어 키를 꾹 눌러 점수를 얻는 것을 방지하였습니다.\n게임 중 Excellent, Good, Miss 판정을 기록합니다. 기록된 판정의 비율에 따라 랭크가 부여됩니다. 게임이 끝나게 되면 판정들을 보여주고, 비율에 따라 그래프를 그려 성취도를 직관적으로 보여줍니다.\n","date":"2021-12-15T00:00:00Z","image":"https://gyeongmin.kr/p/rhythm-game-in-c/image_hu3ff4f112a1159188cba29d5e373d96a1_132087_120x120_fill_box_smart1_3.png","permalink":"https://gyeongmin.kr/p/rhythm-game-in-c/","title":"C언어로 만드는 리듬게임"}]
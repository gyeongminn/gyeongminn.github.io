<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>운영체제 on Gyeongmin의 개발 블로그</title><link>https://gyeongmin.kr/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/</link><description>Recent content in 운영체제 on Gyeongmin의 개발 블로그</description><generator>Hugo -- gohugo.io</generator><language>ko</language><copyright>Gyeongmin Lee</copyright><lastBuildDate>Sat, 20 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://gyeongmin.kr/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/index.xml" rel="self" type="application/rss+xml"/><item><title>프로세스의 동기화와 임계구역 문제 해결 방법</title><link>https://gyeongmin.kr/p/synchronization-tools/</link><pubDate>Sat, 20 Jan 2024 00:00:00 +0000</pubDate><guid>https://gyeongmin.kr/p/synchronization-tools/</guid><description>&lt;img src="https://gyeongmin.kr/images/operating-system.png" alt="Featured image of post 프로세스의 동기화와 임계구역 문제 해결 방법" />&lt;p>여러 프로세스나 스레드가 동시에 실행되는 시스템에서는, 하나의 데이터를 여러 프로세스가 동시에 접근할 때 문제가 발생할 수 있다. 이런 현상을 &lt;strong>경쟁 조건(race condition)&lt;/strong> 이라 부른다. 이 경쟁 조건을 방지하기 위해 프로세스의 실행을 조정하는 메커니즘이 필요하며, 이를 &lt;strong>프로세스 동기화(process synchronization)&lt;/strong> 라고 한다.&lt;/p>
&lt;h2 id="임계구역critical-section이란">임계구역(Critical Section)이란?&lt;/h2>
&lt;p>임계구역이란 하나 이상의 프로세스나 스레드가 공유된 자원을 접근하거나 수정하는 코드 부분을 말한다. 여러 프로세스가 동시에 임계구역에 진입하면 데이터 일관성이 깨질 수 있기 때문에, 임계구역에서는 반드시 한 프로세스만 실행될 수 있도록 해야 한다. 이를 보장하기 위한 조건으로는 다음의 세 가지가 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>상호 배제(mutual exclusion)&lt;/strong>: 당연하게도, 특정 프로세스가 임계구역을 실행 중이라면 다른 프로세스는 진입할 수 없다.&lt;/li>
&lt;li>&lt;strong>진행(progress)&lt;/strong>: 데드락을 피하기 위해, 아무 프로세스도 임계구역에서 실행되지 않을 때, 임계구역에 진입하려는 프로세스가 있다면, 어느 프로세스라도 진입할 수 있는 결정은 반드시 이루어져야 한다.&lt;/li>
&lt;li>&lt;strong>한정된 대기(bounded waiting)&lt;/strong>: 기아 상태를 피하기 위해, 임계구역 진입을 요청한 프로세스가 무한정 대기하지 않고, 제한된 횟수 내에 진입할 수 있어야 한다.&lt;/li>
&lt;/ul>
&lt;h2 id="하드웨어를-통한-동기화-방법">하드웨어를 통한 동기화 방법&lt;/h2>
&lt;p>프로세스 동기화를 소프트웨어만으로 해결하는 방법도 있지만, 현대 시스템은 하드웨어적인 지원을 통해 동기화를 더욱 효율적이고 안정적으로 구현한다. 다음은 대표적인 하드웨어 동기화 방법들이다.&lt;/p>
&lt;h3 id="메모리-장벽memory-barriers">메모리 장벽(Memory Barriers)&lt;/h3>
&lt;p>메모리 장벽은 CPU가 명령어를 재정렬하여 실행하는 것을 방지하는 하드웨어 명령이다. 최신 프로세서는 성능 향상을 위해 연산의 순서를 바꿀 수 있지만, 동기화 작업에서는 명령의 순서가 중요하기 때문에 이를 제어하는 메모리 장벽이 필수적이다. 메모리 장벽은 한 프로세서에서 변경된 메모리 내용이 모든 프로세서에 즉시 반영되도록 보장하여, 프로세서 간 데이터 일관성을 유지한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">X&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">100&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">memory_barrier&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 메모리 장벽
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">flag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위 코드에서는 메모리 장벽이 있으므로 &lt;code>X&lt;/code>의 값이 &lt;code>flag&lt;/code> 값 설정 이전에 확실히 저장된다.&lt;/p>
&lt;h3 id="test-and-set과-compare-and-swap-연산">Test-and-Set과 Compare-and-Swap 연산&lt;/h3>
&lt;p>현대 프로세서는 원자적 연산(Atomic Operation)을 지원하여 프로세스 동기화를 보다 간단히 해결한다. 원자적 연산이란 프로세스가 중단되거나 인터럽트 없이 단일 명령어로 완벽하게 수행되는 연산이다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Test-and-Set 명령어&lt;/strong>는 원자적으로 특정 변수를 검사하고 값을 설정하는 명령이다. 일반적으로 락(lock)을 구현할 때 사용된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">boolean&lt;/span> &lt;span class="nf">test_and_set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">boolean&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">target&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">boolean&lt;/span> &lt;span class="n">rv&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">target&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">*&lt;/span>&lt;span class="n">target&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">rv&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>프로세스는 이 명령어를 통해 락을 얻거나 풀 수 있으며, 한 프로세스가 락을 얻는 동안 다른 프로세스는 이를 기다리게 된다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Compare-and-Swap (CAS)&lt;/strong> 명령어는 세 개의 파라미터를 받아서 특정 메모리의 값을 기대값(expected value)과 비교한 후, 일치할 때에만 새로운 값으로 변경한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">compare_and_swap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">expected&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">new_value&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">value&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">expected&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">*&lt;/span>&lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">new_value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>CAS를 통해 임계구역 진입 여부를 제어하여 동기화를 수행한다.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="원자적-변수atomic-variables">원자적 변수(Atomic Variables)&lt;/h3>
&lt;p>원자적 변수는 프로세스 간에 공유되는 변수를 안전하게 갱신할 수 있도록 지원한다. 예를 들어, 원자적 정수형 변수에 대해 증가(increment) 연산을 수행하면, 이 연산은 원자적으로 처리되어 경쟁 조건을 방지한다.
C#에서는 아래와 같이 사용할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-csharp" data-lang="csharp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">counter&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Interlocked&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Increment&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">ref&lt;/span> &lt;span class="n">counter&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>하지만 원자적 변수만으로는 조건부 대기 문제(예를 들어 버퍼가 비어있을 때 소비자 프로세스가 기다리는 상황 등)는 해결할 수 없기 때문에, 더욱 복잡한 동기화 도구가 필요할 수 있다.&lt;/p>
&lt;h2 id="mutex-locks-뮤텍스-락">Mutex Locks (뮤텍스 락)&lt;/h2>
&lt;p>뮤텍스(mutex)는 &amp;ldquo;Mutual Exclusion&amp;quot;의 줄임말로, 프로세스 간 상호 배제를 간단하게 구현하는 방법이다. 뮤텍스 락은 다음의 두 가지 기본 연산을 제공한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>acquire()&lt;/code>: 락을 얻는다. 만약 락이 이미 획득된 상태라면 대기(busy waiting)하거나 프로세스를 블록시킨다.&lt;/li>
&lt;li>&lt;code>release()&lt;/code>: 락을 반환하여 다른 프로세스가 사용할 수 있게 한다.&lt;/li>
&lt;/ul>
&lt;p>뮤텍스 락은 임계구역을 보호하는 간편한 소프트웨어 도구로서 프로그래머가 쉽게 사용할 수 있으며, 운영체제 수준에서도 널리 활용된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">acquire&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">available&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 락이 풀릴 때까지 대기
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">available&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">release&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">available&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 락을 반환
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>스레드 스케줄링과 멀티코어</title><link>https://gyeongmin.kr/p/thread-scheduling-and-multicore/</link><pubDate>Thu, 21 Dec 2023 00:00:00 +0000</pubDate><guid>https://gyeongmin.kr/p/thread-scheduling-and-multicore/</guid><description>&lt;img src="https://gyeongmin.kr/images/operating-system.png" alt="Featured image of post 스레드 스케줄링과 멀티코어" />&lt;h1 id="스레드-스케줄링과-멀티코어">스레드 스케줄링과 멀티코어&lt;/h1>
&lt;p>운영체제가 여러 작업을 효율적으로 처리할 수 있도록 지원하기 위해, 스레드의 실행 순서를 결정하는 작업을 스레드 스케줄링이라고 부른다. 특히 멀티코어 환경에서 스레드 스케줄링은 더욱 중요하다.&lt;/p>
&lt;h2 id="경쟁-범위-pcs와-scs">경쟁 범위: PCS와 SCS&lt;/h2>
&lt;p>스레드 스케줄링의 개념을 제대로 이해하려면, 먼저 경쟁 범위(contention scope)를 이해해야 한다. 이는 CPU의 실행 권한을 얻기 위한 경쟁이 벌어지는 범위를 뜻한다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>PCS(Process-Contention Scope)&lt;/strong>
이는 같은 프로세스 내부의 사용자 수준 스레드 간 경쟁이다. PCS는 스레드 라이브러리가 직접 관리하며, 가장 우선순위가 높은 사용자 스레드가 먼저 실행된다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>SCS(System-Contention Scope)&lt;/strong>
시스템 전역에서 모든 스레드가 경쟁하는 방식으로, 운영체제가 직접 관리한다. 커널 스레드를 직접 물리적 CPU 코어에 배치한다. Windows와 Linux는 보통 SCS만을 사용한다.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Pthreads에서는 다음 두 가지로 이를 명시적으로 지정할 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>PTHREAD_SCOPE_PROCESS&lt;/code> (PCS)&lt;/li>
&lt;li>&lt;code>PTHREAD_SCOPE_SYSTEM&lt;/code> (SCS)&lt;/li>
&lt;/ul>
&lt;h2 id="다중-처리기-스케줄링">다중 처리기 스케줄링&lt;/h2>
&lt;p>멀티코어 CPU의 등장으로, 운영체제는 여러 코어 간에 스레드를 효과적으로 배분해야 하는 과제를 안게 되었다. 멀티코어 환경에서는 다음과 같은 주요 스케줄링 이슈가 발생한다.&lt;/p>
&lt;h3 id="부하-균등화">부하 균등화&lt;/h3>
&lt;p>부하 균등화(Load Balancing)는 멀티코어 시스템에서 매우 중요하다. 프로세서 간 작업 부하를 균등하게 나누지 않으면, 일부 코어는 유휴 상태가 되고, 다른 코어는 과부하 상태가 된다.&lt;/p>
&lt;p>일반적으로 아래 두 가지의 부하 균등화를 위한 방법이 있다. 이 두 방법은 동시에 사용될 수도 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Push Migration&lt;/strong>: 과부하인 프로세서에서 덜 바쁜 프로세서로 스레드를 이동한다.&lt;/li>
&lt;li>&lt;strong>Pull Migration&lt;/strong>: 한가한 프로세서가 바쁜 프로세서에서 스레드를 가져온다.&lt;/li>
&lt;/ul>
&lt;h3 id="처리기-선호도">처리기 선호도&lt;/h3>
&lt;p>스레드는 특정 프로세서에서 실행되던 메모리 데이터를 캐시에 저장한다. 만약 스레드가 다른 프로세서로 이동하면 캐시 데이터를 다시 불러오는 작업이 필요해 성능이 저하된다. 이를 방지하기 위해 운영체제는 가능한 한 스레드를 동일 프로세서에서 실행시키려 하는데, 이것을 처리기 선호도(Processor Affinity) 라고 한다.&lt;/p>
&lt;p>처리기 선호도는 soft와 hard로 나뉜다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>약한 선호도(soft affinity)&lt;/strong>: 같은 프로세서에서 수행되도록 노력하지만, 이주도 허용된다.&lt;/li>
&lt;li>&lt;strong>강한 선호도(hard affinity)&lt;/strong>: 특정 프로세서에서만 실행되도록 제한한다.&lt;/li>
&lt;/ul>
&lt;h2 id="numa와-멀티코어">NUMA와 멀티코어&lt;/h2>
&lt;p>최근 멀티코어 시스템은 NUMA(non-uniform memory access) 구조를 활용한다. 이는 각 CPU가 가까운 메모리에 빠르게 접근할 수 있지만, 멀리 떨어진 메모리는 느리게 접근할 수 있다는 구조다. 따라서, 스케줄러가 NUMA를 잘 활용하면 프로세서와 메모리 간 접근 속도를 최적화할 수 있다.&lt;/p>
&lt;p>하지만 부하 균등화와 처리기 선호도는 종종 상충 관계를 갖는다. 즉, 선호도를 유지하면 캐시 효율은 좋아지지만 부하 균등화가 힘들어지고, 반대로 부하를 균등하게 맞추려 하면 캐시 효율이 떨어지는 문제가 생긴다.&lt;/p>
&lt;h2 id="최신-운영체제의-멀티코어-스케줄링-사례">최신 운영체제의 멀티코어 스케줄링 사례&lt;/h2>
&lt;h3 id="linux의-cfs-스케줄러">Linux의 CFS 스케줄러&lt;/h3>
&lt;p>Linux는 CFS(Completely Fair Scheduler)를 사용하여 스레드 간 CPU 시간 분배를 공정하게 유지한다. CFS는 스레드마다 가상 실행 시간(vruntime)을 관리하여 가장 작은 vruntime을 가진 스레드를 우선 실행한다. 또한 NUMA를 고려하여 메모리 접근 시간과 캐시 효율을 균형 있게 맞춘다.&lt;/p>
&lt;h3 id="windows의-우선순위-스케줄링">Windows의 우선순위 스케줄링&lt;/h3>
&lt;p>Windows는 우선순위 기반의 선점형 스케줄링을 사용한다. 32단계의 우선순위를 가지며, 스레드는 우선순위에 따라 실행 순서가 정해진다. 또한 멀티코어 환경에서는 각 스레드가 가능한 한 동일 코어에서 실행되도록 노력하며, SMT(동시 멀티스레딩)를 지원하는 하드웨어에서는 같은 물리적 코어 내 하드웨어 스레드를 활용하여 성능을 최적화한다.&lt;/p></description></item><item><title>CPU 스케줄링과 스케줄링 알고리즘</title><link>https://gyeongmin.kr/p/cpu-scheduling/</link><pubDate>Tue, 05 Dec 2023 00:00:00 +0000</pubDate><guid>https://gyeongmin.kr/p/cpu-scheduling/</guid><description>&lt;img src="https://gyeongmin.kr/images/operating-system.png" alt="Featured image of post CPU 스케줄링과 스케줄링 알고리즘" />&lt;h2 id="cpu-스케줄링이란">CPU 스케줄링이란?&lt;/h2>
&lt;p>CPU 스케줄링이란 운영체제가 CPU 자원을 효율적으로 관리하기 위해 프로세스를 선택하여 CPU를 할당하는 과정이다. 다중 프로그래밍 환경에서는 하나의 프로세스가 I/O 작업을 기다리는 동안 CPU가 놀지 않고 다른 프로세스를 실행하여 CPU 이용률을 최대화한다.&lt;/p>
&lt;h2 id="cpu-io-버스트-사이클">CPU-I/O 버스트 사이클&lt;/h2>
&lt;p>CPU 스케줄링의 핵심은 프로세스가 CPU 실행과 I/O 대기를 반복하는 특성에 기반한다. 프로세스는 CPU 버스트로 시작하여, 이후 I/O 버스트와 CPU 버스트가 교차하며 진행된다. 일반적으로 CPU 버스트는 짧은 경우가 많고 긴 경우는 드물다. 이는 CPU 스케줄링 알고리즘 설계에 중요한 영향을 미친다.&lt;/p>
&lt;h2 id="cpu-스케줄링-유형">CPU 스케줄링 유형&lt;/h2>
&lt;h3 id="선점형과-비선점형-스케줄링">선점형과 비선점형 스케줄링&lt;/h3>
&lt;p>선점형 스케줄링은 실행 중인 프로세스를 중단시키고 다른 프로세스에 CPU를 할당할 수 있는 반면, 비선점형 스케줄링은 프로세스가 자발적으로 CPU를 놓아줄 때까지 CPU를 계속 점유하게 한다. 대부분의 현대 운영체제는 선점형 스케줄링을 사용한다.&lt;/p>
&lt;h3 id="주요-cpu-스케줄링-알고리즘">주요 CPU 스케줄링 알고리즘&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>선입선처리(FCFS)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>가장 간단한 방법으로, 먼저 도착한 프로세스부터 처리한다.&lt;/li>
&lt;li>단점: 긴 프로세스 뒤에 짧은 프로세스들이 기다리는 convoy effect가 발생할 수 있다.
convoy effect는 호위 효과라고도 하는데, 마트에서 나는 음료수 한 캔만 계산하면 되는데 앞사람들이 카트 가득 물건을 싣고 계산하고 있는 경우와 같다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>최단 작업 우선(SJF)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>CPU 버스트가 가장 짧은 프로세스를 먼저 처리하여 평균 대기 시간을 최소화한다.&lt;/li>
&lt;li>다음 CPU 버스트 길이를 정확히 예측하기 어렵기 때문에 일반적으로 근사한 예측값을 사용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>라운드 로빈(RR)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>각 프로세스에 동일한 시간 할당량을 부여하며 순차적으로 처리한다.&lt;/li>
&lt;li>시간 할당량이 너무 작으면 잦은 문맥 교환으로 성능이 저하되고, 너무 크면 FCFS와 같은 단점을 가진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>우선순위 스케줄링&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>우선순위가 높은 프로세스를 먼저 처리한다.&lt;/li>
&lt;li>단점: 낮은 우선순위 프로세스가 CPU를 무한히 기다리는 기아 상태(starvation)가 발생할 수 있으며, 이를 방지하기 위해 노화(aging) 기법을 사용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>다단계 큐 스케줄링&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>여러 큐를 만들어 각 큐마다 다른 우선순위와 스케줄링 방식을 적용한다.&lt;/li>
&lt;li>프로세스는 특정 큐에 고정되며, 큐 간에도 스케줄링을 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>다단계 피드백 큐 스케줄링&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>프로세스가 큐 사이를 이동할 수 있으며, CPU 사용량에 따라 우선순위를 동적으로 조정한다.&lt;/li>
&lt;li>기아 상태 방지를 위해 프로세스를 상위 큐로 이동시키는 노화 기법을 사용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="스케줄링-성능-평가-기준">스케줄링 성능 평가 기준&lt;/h2>
&lt;p>스케줄링 알고리즘의 성능을 평가할 때 기준은 여러 가지가 있다.&lt;/p>
&lt;ul>
&lt;li>CPU 이용률(utilization): CPU를 최대한 효율적으로 사용하는 비율&lt;/li>
&lt;li>처리량(throughput): 단위 시간당 처리되는 프로세스 수&lt;/li>
&lt;li>총처리 시간(turnaround time): 프로세스가 시스템에 들어와서 완전히 끝날 때까지의 총 시간&lt;/li>
&lt;li>대기 시간(wating time): 프로세스가 준비 큐에서 대기한 총 시간&lt;/li>
&lt;li>응답 시간(response time): 사용자의 요청 후 첫 응답이 나타날 때까지 걸리는 시간&lt;/li>
&lt;/ul>
&lt;p>이러한 기준들을 통해 상황에 맞는 적절한 스케줄링 알고리즘을 선택하는 것이 바람직하다.&lt;/p></description></item><item><title>스레드와 동시성 (Thread and Concurrency)</title><link>https://gyeongmin.kr/p/thread-and-concurrency/</link><pubDate>Sat, 18 Nov 2023 00:00:00 +0000</pubDate><guid>https://gyeongmin.kr/p/thread-and-concurrency/</guid><description>&lt;img src="https://gyeongmin.kr/images/operating-system.png" alt="Featured image of post 스레드와 동시성 (Thread and Concurrency)" />&lt;h2 id="스레드란">스레드란&lt;/h2>
&lt;p>스레드(Thread)는 CPU가 작업을 수행하는 가장 기본적인 단위이다. 하나의 스레드는 스레드 ID, 프로그램 카운터(PC), 레지스터, 스택으로 구성된다. 여러 개의 스레드는 하나의 프로세스 안에서 생성되어 동작할 수 있는데, 이들은 같은 프로세스에 속해 있기 때문에 코드와 데이터, 파일 및 자원 등을 공유한다.&lt;/p>
&lt;p>&lt;img src="https://gyeongmin.kr/p/thread-and-concurrency/image.png"
width="840"
height="449"
srcset="https://gyeongmin.kr/p/thread-and-concurrency/image_hueb3098c3d072b70ea82bb55e6a0f6e71_67349_480x0_resize_box_3.png 480w, https://gyeongmin.kr/p/thread-and-concurrency/image_hueb3098c3d072b70ea82bb55e6a0f6e71_67349_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="단일 스레드와 다중 스레드 프로세스"
class="gallery-image"
data-flex-grow="187"
data-flex-basis="448px"
>&lt;/p>
&lt;h2 id="스레드를-사용하는-이유">스레드를 사용하는 이유&lt;/h2>
&lt;p>현대의 대부분의 응용 프로그램은 다중 스레드로 설계된다. 예를 들어 웹 브라우저는 하나의 스레드가 웹페이지의 이미지를 로드하는 동안, 또 다른 스레드는 사용자의 입력을 기다릴 수 있다.&lt;/p>
&lt;p>스레드를 사용하면 다음과 같은 이점이 있다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>응답성(responsiveness)&lt;/strong>: 프로그램이 특정 작업으로 인해 멈추지 않고 사용자와 지속적으로 상호작용할 수 있게 해준다. 예를 들어, 워드 프로세서에서 맞춤법 검사를 별도의 스레드로 실행하면 사용자는 검사가 진행되는 동안에도 작업을 계속할 수 있다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>자원 공유(resource sharing)&lt;/strong>: 스레드는 프로세스 내의 데이터를 자연스럽게 공유할 수 있어, 메모리 사용이 효율적이고 프로그램 구조가 간단해진다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>경제성(economy)&lt;/strong>: 새로운 프로세스를 생성하는 것보다 스레드를 생성하는 것이 훨씬 경제적이다. 스레드는 이미 존재하는 프로세스의 자원을 사용하므로 메모리와 처리 시간 측면에서 비용이 적게 든다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>확장성(scalability)&lt;/strong>: 멀티 코어 시스템에서는 각 코어가 서로 다른 스레드를 동시에 실행할 수 있다. 따라서 스레드를 활용하면 시스템의 성능을 효과적으로 확장할 수 있다.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="멀티-코어-프로그래밍">멀티 코어 프로그래밍&lt;/h2>
&lt;p>과거에는 프로세서의 성능 향상이 단일 코어의 성능을 높이는 방식으로 이루어졌지만, 최근에는 한 프로세서에 여러 개의 코어를 장착하는 멀티 코어 방식이 일반화되었다. 멀티 코어 시스템은 동시에 여러 작업을 병렬로 수행하여 전체적인 성능을 높일 수 있게 해준다.&lt;/p>
&lt;p>이러한 멀티 코어 환경에서 성능을 최대화하려면 프로그램이 여러 스레드를 통해 작업을 병렬적으로 처리할 수 있도록 설계되어야 한다. 그러나 단순히 스레드를 많이 만든다고 해서 성능이 반드시 좋아지는 것은 아니다.&lt;/p>
&lt;h3 id="암달의-법칙">암달의 법칙&lt;/h3>
&lt;p>암달의 법칙(Amdahl’s Law)은 병렬 처리를 통해 얻을 수 있는 성능 향상을 나타내는 법칙이다. 이 법칙은 전체 작업 중에서 병렬 처리가 가능한 부분과 반드시 순차적으로 처리해야 하는 부분을 나누고, 여러 개의 코어를 추가할 때의 성능 향상을 예측한다.&lt;/p>
&lt;p>암달의 법칙은 다음과 같은 식으로 표현된다.&lt;/p>
&lt;p>$$\text{speedup} \leq \frac{1}{S + \frac{(1 - S)}{N}}$$&lt;/p>
&lt;ul>
&lt;li>$S$ : 순차적으로만 처리 가능한 작업 비율&lt;/li>
&lt;li>$N$ : 프로세서 코어 수&lt;/li>
&lt;/ul>
&lt;p>이 법칙에 따르면 $N$이 무한대에 가까워지면 속도는 $\frac{1}{S}$에 수렴한다는 것이다. 순차 작업의 비율이 존재하는 한, 아무리 많은 코어를 추가해도 성능 향상에는 명확한 한계가 있다.&lt;/p>
&lt;h2 id="병행성과-병렬성">병행성과 병렬성&lt;/h2>
&lt;p>병행성과 병렬성은 비슷하지만 서로 다른 개념이다.&lt;/p>
&lt;p>&lt;strong>병행성 (concurrency)&lt;/strong> 은 여러 작업이 시간상으로 겹쳐 진행되는 것을 말한다. 하지만 반드시 동시에 수행되는 것은 아니다. 예를 들어, 단일 코어 프로세서에서도 여러 작업을 병행할 수 있는데, CPU가 빠르게 여러 작업을 번갈아 처리하면서 병행성의 효과를 낸다.&lt;/p>
&lt;p>아래 그림에서는 단일 코어 시스템에서 여러 작업(T₁, T₂, T₃, T₄)이 번갈아 수행되는 병행 실행을 나타낸다.&lt;/p>
&lt;p>&lt;img src="https://gyeongmin.kr/p/thread-and-concurrency/image-1.png"
width="1027"
height="133"
srcset="https://gyeongmin.kr/p/thread-and-concurrency/image-1_huc44183dde90899ce9687f46c5ae9a3e9_17644_480x0_resize_box_3.png 480w, https://gyeongmin.kr/p/thread-and-concurrency/image-1_huc44183dde90899ce9687f46c5ae9a3e9_17644_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="싱글 코어 시스템의 실행"
class="gallery-image"
data-flex-grow="772"
data-flex-basis="1853px"
>&lt;/p>
&lt;p>&lt;strong>병렬성 (parallelism)&lt;/strong> 은 여러 작업이 실제로 동시에 수행되는 것이다. 병렬성을 실현하려면 멀티 코어 시스템과 같은 여러 처리기가 필요하다. 즉, 각 작업이 각기 다른 코어에서 동시에 처리되는 방식이다.&lt;/p>
&lt;p>아래 그림에서는 멀티 코어 시스템에서 두 개의 코어가 각기 다른 작업을 동시에 수행하는 병렬 실행을 나타낸다.&lt;/p>
&lt;p>&lt;img src="https://gyeongmin.kr/p/thread-and-concurrency/image-2.png"
width="982"
height="207"
srcset="https://gyeongmin.kr/p/thread-and-concurrency/image-2_hu855662ee086ab3b13167955009f62cad_22648_480x0_resize_box_3.png 480w, https://gyeongmin.kr/p/thread-and-concurrency/image-2_hu855662ee086ab3b13167955009f62cad_22648_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="멀티 코어 시스템의 실행"
class="gallery-image"
data-flex-grow="474"
data-flex-basis="1138px"
>&lt;/p>
&lt;h3 id="병렬-실행의-유형">병렬 실행의 유형&lt;/h3>
&lt;p>병렬 실행은 데이터와 테스크 두 가지 유형으로 나눌 수 있다.&lt;/p>
&lt;p>&lt;img src="https://gyeongmin.kr/p/thread-and-concurrency/image-3.png"
width="934"
height="445"
srcset="https://gyeongmin.kr/p/thread-and-concurrency/image-3_hu095c86db79284cad8e91a5f2abe4628b_47703_480x0_resize_box_3.png 480w, https://gyeongmin.kr/p/thread-and-concurrency/image-3_hu095c86db79284cad8e91a5f2abe4628b_47703_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터 병렬과 테스크 병렬"
class="gallery-image"
data-flex-grow="209"
data-flex-basis="503px"
>&lt;/p>
&lt;p>&lt;strong>데이터 병렬 실행(data parallelism)&lt;/strong> 은 하나의 데이터를 나누어 각 코어가 동일한 작업을 병렬로 수행한다. 예를 들어 큰 배열의 합을 구할 때, 배열을 여러 조각으로 나누어 각각의 코어가 동시에 합을 계산한다.&lt;/p>
&lt;p>&lt;strong>테스크 병렬 실행(task parallelism)&lt;/strong> 은 각 코어가 서로 다른 작업을 병렬로 수행한다. 예를 들어, 하나의 데이터 세트에 대해 한 코어는 평균을 계산하고, 다른 코어는 표준편차를 계산하는 방식이다.&lt;/p></description></item><item><title>프로세스 간 통신 (IPC)</title><link>https://gyeongmin.kr/p/interprocess-communication/</link><pubDate>Sat, 04 Nov 2023 00:00:00 +0000</pubDate><guid>https://gyeongmin.kr/p/interprocess-communication/</guid><description>&lt;img src="https://gyeongmin.kr/images/operating-system.png" alt="Featured image of post 프로세스 간 통신 (IPC)" />&lt;h1 id="프로세스-간-통신">프로세스 간 통신&lt;/h1>
&lt;p>운영체제에서 프로세스란 실행 중인 프로그램을 의미한다.
이 프로세스는 independent 할 수도 있고 cooperative 할 수도 있다. 이 중 cooperative 프로세스가 서로 데이터를 교환하거나 정보를 주고받는 방식을 프로세스 간 통신(IPC, Interprocess Communication)이라고 한다.
운영체제는 정보 공유, 계산 속도 향상, 모듈성을 위해 IPC를 지원한다.&lt;/p>
&lt;p>IPC는 기본적으로 &lt;strong>공유 메모리&lt;/strong>, &lt;strong>메시지 전달&lt;/strong> 방식의 두 모델이 있다.&lt;/p>
&lt;p>&lt;img src="https://gyeongmin.kr/p/interprocess-communication/image.png"
width="773"
height="478"
srcset="https://gyeongmin.kr/p/interprocess-communication/image_hu0b7c6cc069f5dec8e3dd30b0c309f042_62527_480x0_resize_box_3.png 480w, https://gyeongmin.kr/p/interprocess-communication/image_hu0b7c6cc069f5dec8e3dd30b0c309f042_62527_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="(a)Shared Memory, (b)Message Passing"
class="gallery-image"
data-flex-grow="161"
data-flex-basis="388px"
>&lt;/p>
&lt;h2 id="공유-메모리">공유 메모리&lt;/h2>
&lt;p>공유 메모리(Shared Memory) 방식은 프로세스 간 통신을 위해 메모리의 특정 영역을 공유하는 방식이다. 프로세스들이 공통의 메모리 영역을 읽고 쓰면서 데이터를 교환한다.&lt;/p>
&lt;ul>
&lt;li>장점: 시스템 호출(System call)이 거의 필요 없어서 매우 빠르다.&lt;/li>
&lt;li>단점: 프로세스 간 데이터 접근 충돌 문제가 발생할 수 있어 이를 방지하기 위한 동기화가 필요하다.&lt;/li>
&lt;/ul>
&lt;p>공유 메모리는 특히 많은 데이터를 빠르게 교환할 때 효과적이다.&lt;/p>
&lt;h3 id="공유-메모리-방식의-생산자-소비자-문제">공유 메모리 방식의 생산자-소비자 문제&lt;/h3>
&lt;p>공유 메모리를 사용하면 생산자-소비자 문제를 고려해야 한다. 생산자는 데이터를 생성해 공유 메모리에 놓고, 소비자는 이 데이터를 꺼내어 처리한다.&lt;/p>
&lt;p>이때 생산자와 소비자가 동기화되지 않으면 다음과 같은 문제가 발생한다.&lt;/p>
&lt;ul>
&lt;li>소비자가 아직 생산되지 않은 데이터를 읽으려 함&lt;/li>
&lt;li>생산자가 가득 찬 버퍼에 데이터를 넣으려 함&lt;/li>
&lt;/ul>
&lt;p>이를 방지하기 위해 세마포어 등 &lt;strong>동기화 메커니즘&lt;/strong>을 사용하여 생산자와 소비자 간 작업이 원활히 진행되도록 관리해야 한다.&lt;/p>
&lt;hr>
&lt;h2 id="메시지-전달">메시지 전달&lt;/h2>
&lt;p>메시지 전달(Message Passing) 방식은 프로세스 간에 데이터를 메시지 형태로 전달하여 통신하는 방식이다.&lt;/p>
&lt;ul>
&lt;li>장점: 데이터 접근 충돌 문제가 없어 관리가 쉽고 간단하며, 분산 시스템에서 구현이 용이하다.&lt;/li>
&lt;li>단점: 메시지를 주고받을 때마다 커널의 시스템 호출이 필요해 오버헤드가 크고, 속도가 느릴 수 있다.&lt;/li>
&lt;/ul>
&lt;p>메시지 전달 방식은 소규모 데이터나 명확한 메시지 전달이 필요한 상황에서 적합하다.&lt;/p>
&lt;h3 id="메시지-전달-시스템의-종류">메시지 전달 시스템의 종류&lt;/h3>
&lt;p>서로를 가리킬 방법에 따라 직접 혹은 간접으로 나눌 수 있다.&lt;/p>
&lt;ul>
&lt;li>직접 통신: 프로세스가 메시지를 주고받을 상대 프로세스를 직접 지정한다.&lt;/li>
&lt;li>간접 통신: 메시지를 메일박스(또는 포트)를 통해 전달한다. 프로세스들은 공유된 메일박스를 통해 통신한다.&lt;/li>
&lt;/ul>
&lt;p>혹은 블락킹 여부로 나눌 수 있다.&lt;/p>
&lt;ul>
&lt;li>동기식: 메시지를 보내거나 받을 때 상대 프로세스가 준비될 때까지 대기(Blocking)한다.&lt;/li>
&lt;li>비동기식: 메시지를 보내거나 받을 때 상대 프로세스가 준비되지 않았더라도 바로 다음 작업을 진행(Non-blocking)한다.&lt;/li>
&lt;/ul>
&lt;h2 id="파이프를-통한-ipc">파이프를 통한 IPC&lt;/h2>
&lt;p>파이프(Pipes)는 메세지 패싱의 한 예시로, 데이터를 한 방향으로 흘려보내는 통로이다.&lt;/p>
&lt;h3 id="일반-파이프">일반 파이프&lt;/h3>
&lt;p>일반 파이프(Ordinary Pipe)는 주로 부모와 자식 프로세스 간의 단방향 통신에 사용된다.&lt;/p>
&lt;ul>
&lt;li>단방향으로만 데이터를 전달한다. (양방향 통신 시 두 개의 파이프 필요)&lt;/li>
&lt;li>프로세스 간에 반드시 부모-자식 관계가 있어야 한다.&lt;/li>
&lt;li>같은 시스템 내부에서만 통신 가능하다.&lt;/li>
&lt;/ul>
&lt;p>예를 들어, &lt;code>ls | more&lt;/code> 명령어는 &lt;code>ls&lt;/code>의 출력을 &lt;code>more&lt;/code>의 입력으로 전달하는 파이프를 사용한다.&lt;/p>
&lt;h3 id="지명-파이프">지명 파이프&lt;/h3>
&lt;p>지명 파이프(Named Pipe)는 파일 시스템에 이름을 가진 형태로 존재해, 부모-자식 관계 없이 서로 다른 프로세스 간 통신에 사용할 수 있다.&lt;/p>
&lt;ul>
&lt;li>파일 시스템에서 이름을 가지고 존재한다.&lt;/li>
&lt;li>프로세스가 종료되어도 지명 파이프는 계속 유지된다.&lt;/li>
&lt;li>같은 시스템 내부 또는 네트워크를 통해 서로 다른 시스템 간에도 통신 가능하다.&lt;/li>
&lt;/ul>
&lt;h2 id="클라이언트-서버-시스템의-ipc">클라이언트-서버 시스템의 IPC&lt;/h2>
&lt;p>클라이언트-서버 통신에서는 일반적으로 소켓과 원격 프로시저 호출(Remote Procedure Call, RPC)을 사용한다.&lt;/p>
&lt;h3 id="소켓">소켓&lt;/h3>
&lt;p>소켓(Socket)은 네트워크를 통해 서로 다른 시스템의 프로세스들이 통신할 때 사용되는 End Point다. 소켓은 IP 주소와 포트 번호를 이용하여 식별된다. 웹 서버(HTTP), FTP 서버 등의 통신에 널리 사용된다.&lt;/p>
&lt;h3 id="원격-프로시저-호출">원격 프로시저 호출&lt;/h3>
&lt;p>RPC는 네트워크상 다른 시스템에 존재하는 프로세스의 함수를 마치 자신의 로컬 함수처럼 호출할 수 있게 한다.&lt;/p>
&lt;p>RPC는 내부적으로 매개변수를 변환하는 마샬링(Marshalling)을 수행한다. 또한 복잡한 네트워크 통신을 추상화하여 프로그래머에게 편리한 인터페이스를 제공한다. RPC를 사용하는 예시로는 Android의 Binder가 있다.&lt;/p></description></item><item><title>프로세스 스케줄링의 개념</title><link>https://gyeongmin.kr/p/process-scheduling/</link><pubDate>Tue, 17 Oct 2023 00:00:00 +0000</pubDate><guid>https://gyeongmin.kr/p/process-scheduling/</guid><description>&lt;img src="https://gyeongmin.kr/images/operating-system.png" alt="Featured image of post 프로세스 스케줄링의 개념" />&lt;h2 id="프로세스-스케줄링의-필요성">프로세스 스케줄링의 필요성&lt;/h2>
&lt;p>운영체제는 여러 프로세스를 관리하며 CPU의 효율적인 활용을 위해 프로세스 스케줄링을 수행한다.&lt;/p>
&lt;p>프로세스 스케줄링은 여러 프로세스가 동시에 메모리에 존재하는 다중 프로그래밍 환경에서 더욱 중요하다. 다중 프로그래밍에선 항상 어떤 프로세스를 실행하도록 하여 CPU이용을 최대화해야 한다. 또한 시분할 시스템에서는 프로세스들 사이에서 CPU 코어를 빈번하게 교체하여 각 사용자에게 빠른 응답을 제공해야 한다. 이러한 목적을 달성하기 위해 &lt;strong>프로세스 스케줄러&lt;/strong>는 코어에서 실행 가능한 여러 프로세스 중에서 하나의 프로세스를 선택한다.&lt;/p>
&lt;p>다중 코어 시스템에서는 동시에 여러 프로세스를 실행할 수 있지만, 단일 코어 시스템에서는 동시에 하나의 프로세스만 실행할 수 있다.&lt;/p>
&lt;h2 id="스케줄링-큐">스케줄링 큐&lt;/h2>
&lt;p>운영체제는 프로세스를 관리하기 위해 여러 개의 큐(queue)를 사용한다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>준비 큐(Ready Queue)&lt;/strong>&lt;br>
프로세스가 실행 준비를 마치고 CPU 할당을 기다리는 큐이다. 준비 큐는 일반적으로 연결 리스트(linked list)의 형태로 관리된다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>대기 큐(Wait Queue)&lt;/strong>&lt;br>
프로세스가 I/O 작업이나 특정 이벤트를 기다릴 때 들어가는 큐이다. 예를 들어 프로세스가 디스크나 네트워크 작업을 수행하는 동안, CPU는 다른 프로세스를 실행하여 유휴 시간을 최소화할 수 있다.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>큐는 연결 리스트 형태로 관리되며, 프로세스 제어 블록(PCB)이 각 프로세스를 표현하고 큐에 연결된다. 프로세스가 I/O를 요청하면, 해당 프로세스는 준비 큐에서 제거되어 I/O 대기 큐로 이동한다. I/O 작업이 완료되면 프로세스는 다시 준비 큐로 이동하여 CPU를 기다리게 된다.&lt;/p>
&lt;h2 id="cpu-스케줄링">CPU 스케줄링&lt;/h2>
&lt;p>CPU 스케줄링(CPU Scheduling)은 준비 큐에 있는 여러 프로세스 중 하나를 선택하여 CPU를 할당하는 작업이다. 스케줄러는 프로세스가 CPU를 독점하지 않도록 주기적으로 실행되어 프로세스를 교체한다. 일반적으로 CPU 스케줄러는 매우 짧은 주기로 동작하여, 시분할 시스템에서는 프로세스들이 CPU를 빠르게 번갈아 사용하도록 한다.&lt;/p>
&lt;p>프로세스는 보통 두 가지 유형으로 구분된다,&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>I/O 바운드 프로세스&lt;/strong>&lt;br>
계산보다 입출력 작업에 더 많은 시간을 소비하는 프로세스이다. 이러한 프로세스는 CPU를 짧게 사용하고 자주 I/O 요청을 한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>CPU 바운드 프로세스&lt;/strong>&lt;br>
대부분의 시간을 계산에 소비하고 I/O 요청을 거의 하지 않는 프로세스이다. 스케줄러는 이런 프로세스가 CPU를 장기간 독점하지 않도록 중간에 강제로 중단시켜 다른 프로세스에게 CPU를 할당한다.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>또한, 메모리가 부족한 상황에서는 프로세스를 디스크로 이동시켜 일시적으로 메모리에서 제거하는 &lt;strong>스와핑&lt;/strong>을 통해 프로세스의 수를 줄이는 중간 스케줄링이 수행되기도 한다.&lt;/p>
&lt;h2 id="컨텍스트-스위칭">컨텍스트 스위칭&lt;/h2>
&lt;p>&lt;img src="https://gyeongmin.kr/p/process-scheduling/image.png"
width="1264"
height="778"
srcset="https://gyeongmin.kr/p/process-scheduling/image_hu7ad9ba65f925b46b5a20f00a78b8aded_207105_480x0_resize_box_3.png 480w, https://gyeongmin.kr/p/process-scheduling/image_hu7ad9ba65f925b46b5a20f00a78b8aded_207105_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="컨텍스트 스위치 다이어그램"
class="gallery-image"
data-flex-grow="162"
data-flex-basis="389px"
>&lt;/p>
&lt;p>컨텍스트 스위칭(Context Switch)이란 CPU가 하나의 프로세스에서 다른 프로세스로 전환될 때, 현재 프로세스의 상태를 저장하고, 새롭게 실행될 프로세스의 상태를 복원하는 작업이다. 컨텍스트 스위칭은 다음과 같은 과정을 포함한다:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>상태 저장(state save)&lt;/strong>: 현재 실행 중인 프로세스의 CPU 레지스터 값과 상태 정보를 PCB에 저장한다.&lt;/li>
&lt;li>&lt;strong>상태 복구(state restore)&lt;/strong>: 다음 실행할 프로세스의 PCB에 저장된 정보를 CPU 레지스터와 상태에 복원한다.&lt;/li>
&lt;/ul>
&lt;p>컨텍스트 스위칭은 반드시 필요한 작업이지만, 시스템에 직접적으로 기여하는 작업이 아니므로 수행되는 동안은 시스템에 부하가 생긴다. 컨텍스트 스위칭 시간은 순수한 오버헤드로 간주되며, 보통 수 ms의 짧은 시간이지만 자주 발생하면 성능에 상당한 영향을 줄 수 있다.&lt;/p>
&lt;p>일부 CPU 하드웨어는 여러 개의 레지스터 세트를 사용하여 컨텍스트 스위칭 속도를 높이기도 하지만, 메모리 관리 기법이 복잡할수록 컨텍스트 스위칭 시 수행해야 할 작업량도 증가한다.&lt;/p></description></item><item><title>프로세스의 개념에 대한 이해</title><link>https://gyeongmin.kr/p/process/</link><pubDate>Sun, 01 Oct 2023 00:00:00 +0000</pubDate><guid>https://gyeongmin.kr/p/process/</guid><description>&lt;img src="https://gyeongmin.kr/images/operating-system.png" alt="Featured image of post 프로세스의 개념에 대한 이해" />&lt;h2 id="프로세스">프로세스&lt;/h2>
&lt;p>간단하게 말하자면, 프로세스는 &lt;strong>실행 중인&lt;/strong> 프로그램을 의미한다.&lt;/p>
&lt;p>프로그램 자체는 단지 명령어가 저장된 파일에 불과한 수동적인 존재이지만, 이것이 메모리에 적재되어 실행될 때 프로그램 카운터와 메모리, 레지스터 같은 자원을 가진 능동적인 존재, 프로세스가 된다.&lt;/p>
&lt;p>프로세스의 현재 활동의 상태는 프로그램 카운터 값과 프로세서 레지스터의 내용으로 나타낸다.&lt;/p>
&lt;h2 id="프로세스의-메모리-구조">프로세스의 메모리 구조&lt;/h2>
&lt;p>&lt;img src="https://gyeongmin.kr/p/process/image.png"
width="1020"
height="700"
srcset="https://gyeongmin.kr/p/process/image_hu7eb73bfae1171d337dccaaf19cfc1c63_60471_480x0_resize_box_3.png 480w, https://gyeongmin.kr/p/process/image_hu7eb73bfae1171d337dccaaf19cfc1c63_60471_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="프로세스 메모리 배치"
class="gallery-image"
data-flex-grow="145"
data-flex-basis="349px"
>&lt;/p>
&lt;p>프로세스는 메모리에서 다음과 같은 네 가지 주요 섹션으로 나뉜다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>텍스트(Text)&lt;/strong>: 실행할 프로그램 코드가 저장되는 곳으로, 실행 중 크기가 변하지 않는다.&lt;/li>
&lt;li>&lt;strong>데이터(Data)&lt;/strong>: 전역 변수와 같은 데이터가 저장되는 곳으로, 초기화된 데이터와 초기화되지 않은 데이터로 나뉠 수 있다.&lt;/li>
&lt;li>&lt;strong>힙(Heap)&lt;/strong>: 프로세스 실행 중 동적으로 할당되는 메모리가 저장되는 공간으로, 크기가 실행 중에 동적으로 변경된다.&lt;/li>
&lt;li>&lt;strong>스택(Stack)&lt;/strong>: 함수 호출 시 임시 데이터(함수 매개변수, 복귀 주소, 지역 변수 등)를 저장하는 공간으로, 함수 호출 및 복귀에 따라 크기가 변한다.&lt;/li>
&lt;/ul>
&lt;p>스택과 힙 영역이 충돌하지 않도록 운영체제가 관리해야 한다.&lt;/p>
&lt;h2 id="프로세스의-상태-변화">프로세스의 상태 변화&lt;/h2>
&lt;p>&lt;img src="https://gyeongmin.kr/p/process/image-1.png"
width="1562"
height="563"
srcset="https://gyeongmin.kr/p/process/image-1_hu6e1f5563677bb8e903f5c3f6829d7d34_340829_480x0_resize_box_3.png 480w, https://gyeongmin.kr/p/process/image-1_hu6e1f5563677bb8e903f5c3f6829d7d34_340829_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="프로세스의 상태 다이어그램"
class="gallery-image"
data-flex-grow="277"
data-flex-basis="665px"
>&lt;/p>
&lt;p>프로세스는 실행되면서 상태가 변한다. 상태의 이름은 운영체제마다 다를 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>New&lt;/strong>: 프로세스가 생성되고 있는 상태.&lt;/li>
&lt;li>&lt;strong>Running&lt;/strong>: 실제 CPU에서 명령어가 수행되는 상태.&lt;/li>
&lt;li>&lt;strong>Waiting&lt;/strong>: 입출력 또는 특정 이벤트가 발생할 때까지 기다리는 상태.&lt;/li>
&lt;li>&lt;strong>Ready&lt;/strong>: 실행될 준비가 되었지만 CPU가 할당되지 않은 상태.&lt;/li>
&lt;li>&lt;strong>Terminated&lt;/strong>: 프로세스의 실행이 종료된 상태.&lt;/li>
&lt;/ul>
&lt;p>운영체제는 이러한 상태를 관리하면서 프로세스가 원활히 수행되도록 한다.&lt;/p>
&lt;h2 id="프로세스-제어-블록pcb">프로세스 제어 블록(PCB)&lt;/h2>
&lt;p>&lt;img src="https://gyeongmin.kr/p/process/image-2.png"
width="857"
height="778"
srcset="https://gyeongmin.kr/p/process/image-2_huf7ce1b934abcffc649ca9eafb0eca96f_206487_480x0_resize_box_3.png 480w, https://gyeongmin.kr/p/process/image-2_huf7ce1b934abcffc649ca9eafb0eca96f_206487_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Process Control Block"
class="gallery-image"
data-flex-grow="110"
data-flex-basis="264px"
>&lt;/p>
&lt;p>프로세스의 모든 정보는 운영체제 내부에서 &lt;strong>PCB(Process Control Block)&lt;/strong> 에 저장된다. PCB는 프로세스의 신분증과 같은 역할을 하며 다음 정보를 포함한다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>프로세스 상태&lt;/strong>: 현재 상태(New, Running, Waiting, Ready, Terminated 등)&lt;/li>
&lt;li>&lt;strong>프로그램 카운터(PC)&lt;/strong>: 다음 실행할 명령어의 주소&lt;/li>
&lt;li>&lt;strong>레지스터 정보&lt;/strong>: CPU 레지스터 상태&lt;/li>
&lt;li>&lt;strong>메모리 관리 정보&lt;/strong>: 메모리 할당 정보(페이지 테이블 등)&lt;/li>
&lt;li>&lt;strong>CPU 스케줄링 정보&lt;/strong>: 프로세스의 우선순위 및 스케줄링 정보&lt;/li>
&lt;li>&lt;strong>입출력 상태 정보&lt;/strong>: 열린 파일 목록 등 프로세스가 사용하는 입출력 자원 정보&lt;/li>
&lt;/ul></description></item><item><title>인터럽트의 개념과 분류, 처리 과정에 대하여</title><link>https://gyeongmin.kr/p/interrupt/</link><pubDate>Tue, 12 Sep 2023 00:00:00 +0000</pubDate><guid>https://gyeongmin.kr/p/interrupt/</guid><description>&lt;img src="https://gyeongmin.kr/images/operating-system.png" alt="Featured image of post 인터럽트의 개념과 분류, 처리 과정에 대하여" />&lt;h2 id="인터럽트">인터럽트&lt;/h2>
&lt;p>인터럽트는 컴퓨터 시스템에서 비동기적 이벤트를 처리하는 중요한 메커니즘이다.&lt;/p>
&lt;p>하드웨어 장치나 외부 이벤트가 발생할 때, CPU가 현재 작업을 중단하고 새로운 작업을 처리하도록 유도한다.&lt;/p>
&lt;p>예를 들어, 키보드 입력이나 디스크 작업 완료 등의 사건이 발생하면 해당 장치 컨트롤러는 인터럽트를 발생시킨다.&lt;/p>
&lt;h2 id="인터럽트-처리-과정">인터럽트 처리 과정&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>CPU가 인터럽트를 수신하면 실행 중이던 프로그램의 작업을 즉시 중단한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>인터럽트 번호를 인터럽트 벡터의 인덱스로 사용하여 ISR(Interrupt Service Routine)의 시작 주소를 가져온다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CPU는 PC(Program Counter) 및 레지스터 상태를 스택에 저장하여 보관하고, ISR 코드가 위치한 주소로 제어를 넘긴다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>진행 중인 프로그램의 레지스터 값들도 스택 또는 지정된 저장 공간에 대피시킨다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ISR(인터럽트 서비스 루틴)이 실행되어 요청된 작업을 처리한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ISR 작업이 끝나면, CPU는 스택에서 이전 프로그램의 레지스터 상태와 PC 값을 복원한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>IRET(Interrupt Return) 명령어를 실행하여 원래의 프로그램 수행 위치로 복귀한다.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="인터럽트-분류">인터럽트 분류&lt;/h2>
&lt;p>인터럽트는 크게 세 가지 종류로 나눌 수 있다.&lt;/p>
&lt;h3 id="내부-인터럽트-internal-interrupt-exception">내부 인터럽트 (Internal Interrupt, Exception)&lt;/h3>
&lt;p>내부 인터럽트는 CPU가 명령어를 실행하는 도중에 내부적으로 발생하는 인터럽트다.
크게 트랩(Trap)과 폴트(Fault), 어보트(Abort) 세 가지 유형으로 나뉜다.&lt;/p>
&lt;h4 id="트랩-trap">트랩 (Trap)&lt;/h4>
&lt;p>프로그래머가 의도적으로 만든 인터럽트. 주로 디버깅 또는 특정 시스템 콜 호출 시 사용된다.&lt;/p>
&lt;ul>
&lt;li>breakpoint(중단점)&lt;/li>
&lt;/ul>
&lt;h4 id="폴트-fault">폴트 (Fault)&lt;/h4>
&lt;p>실행 중인 명령어에서 오류가 발생하여 이를 바로잡기 위해 발생한다. 문제가 해결되면 다시 명령을 재실행할 수 있다.&lt;/p>
&lt;ul>
&lt;li>페이지 폴트(Page Fault)&lt;/li>
&lt;li>일반 보호 예외(General Protection Fault)&lt;/li>
&lt;/ul>
&lt;h4 id="어보트-abort">어보트 (Abort)&lt;/h4>
&lt;p>프로그램의 심각한 오류가 발생해 복구할 수 없을 때 CPU가 강제로 실행을 중단시키기 위한 인터럽트이다. 일반적으로 프로그램 종료로 이어진다.&lt;/p>
&lt;ul>
&lt;li>더블 폴트(Double Fault)&lt;/li>
&lt;/ul>
&lt;h3 id="외부-인터럽트-external-interrupt-hardware-interrupt">외부 인터럽트 (External Interrupt, Hardware Interrupt)&lt;/h3>
&lt;p>컴퓨터 시스템 외부의 하드웨어 장치가 발생시키는 인터럽트다.
예를 들어, 키보드 입력, 마우스 클릭, 타이머 시간 초과, 디스크 입출력 완료 등이 해당된다.&lt;/p>
&lt;ul>
&lt;li>타이머 인터럽트: 정기적으로 일정 시간 간격마다 CPU에게 인터럽트를 발생시켜 작업을 전환하게 해준다.&lt;/li>
&lt;li>입출력 장치 인터럽트: 키보드, 마우스 등 주변 장치 입력 처리&lt;/li>
&lt;/ul>
&lt;h3 id="소프트웨어-인터럽트-software-interrupt">소프트웨어 인터럽트 (Software Interrupt)&lt;/h3>
&lt;p>소프트웨어가 의도적으로 명령어로 인터럽트를 발생시키는 경우다.
주로 운영체제 서비스 호출이나 시스템 호출(system call)을 요청할 때 사용된다.&lt;/p>
&lt;ul>
&lt;li>시스템 콜 인터럽트: 사용자 프로그램이 운영체제의 특정 기능을 사용하고자 인터럽트를 발생시킨다. (예: INT 0x80 리눅스 시스템 콜)&lt;/li>
&lt;/ul>
&lt;h3 id="인터럽트의-우선순위">인터럽트의 우선순위&lt;/h3>
&lt;p>인터럽트가 여러 개 동시에 발생하면 CPU는 인터럽트의 우선순위(priority)에 따라 처리 순서를 결정한다. 일반적으로 더 중요하거나 긴급한 인터럽트가 우선 처리된다.&lt;/p>
&lt;p>예를 들어, 타이머 인터럽트는 낮은 우선순위를 가질 수 있지만, 치명적인 하드웨어 오류를 나타내는 인터럽트(예: 더블 폴트)는 높은 우선순위를 가진다.&lt;/p>
&lt;h3 id="인터럽트-종류">인터럽트 종류&lt;/h3>
&lt;table style="width: 50%; min-width: 24rem; margin: 0 auto; border-collapse: collapse;">
&lt;thead>
&lt;tr>
&lt;th style="border: 1px solid black; padding: 8px;">벡터 번호&lt;/th>
&lt;th style="border: 1px solid black; padding: 8px;">설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="border: 1px solid black; padding: 8px;">0&lt;/td>
&lt;td style="border: 1px solid black; padding: 8px;">나눗셈 에러&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="border: 1px solid black; padding: 8px;">1&lt;/td>
&lt;td style="border: 1px solid black; padding: 8px;">디버그 예외&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="border: 1px solid black; padding: 8px;">2&lt;/td>
&lt;td style="border: 1px solid black; padding: 8px;">Null 인터럽트&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="border: 1px solid black; padding: 8px;">3&lt;/td>
&lt;td style="border: 1px solid black; padding: 8px;">중단점(breakpoint)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="border: 1px solid black; padding: 8px;">4&lt;/td>
&lt;td style="border: 1px solid black; padding: 8px;">INTO-검출 오버플로&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="border: 1px solid black; padding: 8px;">5&lt;/td>
&lt;td style="border: 1px solid black; padding: 8px;">제한 범위 예외&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="border: 1px solid black; padding: 8px;">6&lt;/td>
&lt;td style="border: 1px solid black; padding: 8px;">유효하지 않은 opcode&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="border: 1px solid black; padding: 8px;">7&lt;/td>
&lt;td style="border: 1px solid black; padding: 8px;">장치 사용하지 않음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="border: 1px solid black; padding: 8px;">8&lt;/td>
&lt;td style="border: 1px solid black; padding: 8px;">더블 폴트&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="border: 1px solid black; padding: 8px;">9&lt;/td>
&lt;td style="border: 1px solid black; padding: 8px;">부처리기 세그먼트 침범(예약됨)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="border: 1px solid black; padding: 8px;">10&lt;/td>
&lt;td style="border: 1px solid black; padding: 8px;">유효하지 않은 태스크 상태 세그먼트&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="border: 1px solid black; padding: 8px;">11&lt;/td>
&lt;td style="border: 1px solid black; padding: 8px;">존재하지 않는 세그먼트&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="border: 1px solid black; padding: 8px;">12&lt;/td>
&lt;td style="border: 1px solid black; padding: 8px;">스택 폴트&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="border: 1px solid black; padding: 8px;">13&lt;/td>
&lt;td style="border: 1px solid black; padding: 8px;">일반 보호&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="border: 1px solid black; padding: 8px;">14&lt;/td>
&lt;td style="border: 1px solid black; padding: 8px;">페이지 폴트&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="border: 1px solid black; padding: 8px;">32-255&lt;/td>
&lt;td style="border: 1px solid black; padding: 8px;">Maskable 인터럽트&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item></channel></rss>